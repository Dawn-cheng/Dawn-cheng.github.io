<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Dawn-cheng个人博客">
<meta name="description" content="温故而知新">
<meta name="theme-color" content="#000">
<title>Dawn-cheng</title>
<link rel="shortcut icon" href="/favicon.ico?v=1599390487151">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Dawn-cheng</span>
            </a>  
          
        </div>
        
          <p class="subtitle">你的心态就是你人生最大本钱</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                
                  <a href="/" target="_self">
                    <i class="fa fa-home"></i> 首页
                  </a>
                
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                
                  <a href="/archives/" target="_self">
                    <i class="fa fa-archive"></i> 归档
                  </a>
                
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                
                  <a href="/tags/" target="_self">
                    <i class="fa fa-tags"></i> 标签
                  </a>
                
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout  pisces">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Dawn-cheng</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">18</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">7</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">7</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'pisces';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box tag-line box-shadow-wrapper">
          <section class="section tags-section posts-expand bg-color">
            <div class="padding-wrapper">
  <div class="tag-timeline-box">
    <div class="tag-timeline-wrapper">
      <div class="tag-timeline-title">
        <h2>
          JS
          <small class="language" data-lan="tag">标签</small>
        </h2>
      </div>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="https://Dawn-cheng.github.io/916fEKaXJ/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              08-05
              <small>uni-app canvas 绘制海报图</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="https://Dawn-cheng.github.io/nqk-kNdhD/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              07-15
              <small>JS中的forEach,for in,for of和for的遍历优缺点及区别</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </div>
  </div>
</div>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="poweredby">
      @2020 <a href="https://github.com/Dawn-cheng" target="_blank">Dawn-cheng</a> 
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
  <div class="bg-img">
    <img src="/media/images/custom-bgImg.jpg" />
  </div>
  
  
  
  
  
  <script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://player.lmih.cn/player/js/player.js" id="myhk" key="demo" m="1"></script>


  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>
  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/amB0AixTy/"" data-c="
          &lt;h2 id=&#34;1-show-profile-分析慢查询&#34;&gt;1 show profile 分析慢查询&lt;/h2&gt;
&lt;p&gt;有时需要确定 SQL 到底慢在哪个环节，此时 explain 可能不好确定。在 MySQL 数据库中，通过 profile，能够更清楚地了解 SQL 执行过程的资源使用情况，能让我们知道到底慢在哪个环节。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;``知识扩展：可以通过配置参数 profiling = 1 来启用 SQL 分析。该参数可以在全局和 session 级别来设置。对于全局级别则作用于整个MySQL 实例，而 session 级别仅影响当前 session 。该参数开启后，后续执行的 SQL 语句都将记录其资源开销，如 IO、上下文切换、CPU、Memory等等。根据这些开销进一步分析当前 SQL 从而进行优化与调整。```&lt;/p&gt;
&lt;p&gt;下面我们来讲一下如何使用 profile 分析慢查询，大致步骤是：确定这个 MySQL 版本是否支持 profile；确定 profile 是否关闭；开启 profile；执行 SQL；查看执行完 SQL 的 query id；通过 query id 查看 SQL 的每个状态及耗时时间。&lt;/p&gt;
&lt;p&gt;1.1 确定是否支持 profile&lt;br&gt;
我们进行第一步，用下面命令来判断当前 MySQL 是否支持 profile：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select @@have_profiling;

+------------------+
| @@have_profiling |
+------------------+
| YES              |
+------------------+

1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面结果中可以看出是YES，表示支持profile的。&lt;/p&gt;
&lt;p&gt;1.2 查看 profiling 是否关闭的&lt;br&gt;
进行第二步，用下面命令判断 profiling 参数是否关闭（默认 profiling 是关闭的）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select @@profiling;

+-------------+
| @@profiling |
+-------------+
|           0 |
+-------------+

1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果显示为 0，表示 profiling 参数状态是关闭的。&lt;/p&gt;
&lt;p&gt;1.3 通过 set 开启 profile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; set profiling=1;

Query OK, 0 rows affected, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tips：set 时没加 global，只对当前 session 有效。&lt;/p&gt;
&lt;p&gt;1.4 执行 SQL 语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from t1 where b=1000;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.5 确定 SQL 的 query id&lt;br&gt;
通过 show profiles 语句确定执行过的 SQL 的 query id：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show profiles;
+----------+------------+-------------------------------+
| Query_ID | Duration   | Query                         |
+----------+------------+-------------------------------+
|        1 | 0.00063825 | select * from t1 where b=1000 |
+----------+------------+-------------------------------+
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.6 查询 SQL 执行详情&lt;br&gt;
通过 show profile for query 可看到执行过的 SQL 每个状态和消耗时间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show profile for query 1;
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| starting             | 0.000115 |
| checking permissions | 0.000013 |
| Opening tables       | 0.000027 |
| init                 | 0.000035 |
| System lock          | 0.000017 |
| optimizing           | 0.000016 |
| statistics           | 0.000025 |
| preparing            | 0.000020 |
| executing            | 0.000006 |
| Sending data         | 0.000294 |
| end                  | 0.000009 |
| query end            | 0.000012 |
| closing tables       | 0.000011 |
| freeing items        | 0.000024 |
| cleaning up          | 0.000016 |
+----------------------+----------+
15 rows in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过以上结果，可以确定 SQL 执行过程具体在哪个过程耗时比较久，从而更好地进行 SQL 优化与调整。&lt;/p&gt;
&lt;h2 id=&#34;2-trace-分析-sql-优化器&#34;&gt;2 trace 分析 SQL 优化器&lt;/h2&gt;
&lt;p&gt;从前面学到了 explain 可以查看 SQL 执行计划，但是无法知道它为什么做这个决策，如果想确定多种索引方案之间是如何选择的或者排序时选择的是哪种排序模式，有什么好的办法吗？&lt;/p&gt;
&lt;p&gt;从 MySQL 5.6 开始，可以使用 trace 查看优化器如何选择执行计划。&lt;/p&gt;
&lt;p&gt;通过trace，能够进一步了解为什么优化器选择A执行计划而不是选择B执行计划，或者知道某个排序使用的排序模式，帮助我们更好地理解优化器行为。&lt;/p&gt;
&lt;p&gt;如果需要使用，先开启 trace，设置格式为 JSON，再执行需要分析的 SQL，最后查看 trace 分析结果（在 information_schema.OPTIMIZER_TRACE 中）。&lt;/p&gt;
&lt;p&gt;开启该功能，会对 MySQL 性能有所影响，因此只建议分析问题时临时开启。&lt;/p&gt;
&lt;p&gt;下面一起来看下 trace 的使用方法。使用讲解 explain 时创建的表t1做实验。&lt;/p&gt;
&lt;p&gt;首先构造如下 SQL (表示取出表 t1 中 a 的值大于 900 并且 b 的值大于 910 的数据，然后按照 a 字段排序)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from t1 where a &amp;gt;900 and b &amp;gt; 910 order  by a;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们首先用 explain 分析下执行计划：&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1599390318027.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图片描述通过上面执行计划中 key 这个字段可以看出，该语句使用的是 b 字段的索引 idx_b。实际表 t1 中，a、b 两个字段都有索引，为什么条件中有这两个索引字段却偏偏选了 b 字段的索引呢？这时就可以使用 trace 进行分析。大致步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; set session optimizer_trace=&amp;quot;enabled=on&amp;quot;,end_markers_in_json=on;
/* optimizer_trace=&amp;quot;enabled=on&amp;quot; 表示开启 trace；end_markers_in_json=on 表示 JSON 输出开启结束标记 */
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; select * from t1 where a &amp;gt;900 and b &amp;gt; 910 order  by a;
+------+------+------+
| id   | a    | b    |
+------+------+------+
|    1 |    1 |    1 |
|    2 |    2 |    2 |

......

| 1000 | 1000 | 1000 |
+------+------+------+
1000 rows in set (0.00 sec)

mysql&amp;gt; SELECT * FROM information_schema.OPTIMIZER_TRACE\G
*************************** 1. row ***************************
QUERY: select * from t1 where a &amp;gt;900 and b &amp;gt; 910 order  by a    --SQL语句
TRACE: {
  &amp;quot;steps&amp;quot;: [
    {
      &amp;quot;join_preparation&amp;quot;: {				--SQL准备阶段
        &amp;quot;select#&amp;quot;: 1,
        &amp;quot;steps&amp;quot;: [
          {
            &amp;quot;expanded_query&amp;quot;: &amp;quot;/* select#1 */ select `t1`.`id` AS `id`,`t1`.`a` AS `a`,`t1`.`b` AS `b`,`t1`.`create_time` AS `create_time`,`t1`.`update_time` AS `update_time` from `t1` where ((`t1`.`a` &amp;gt; 900) and (`t1`.`b` &amp;gt; 910)) order by `t1`.`a`&amp;quot;
          }
        ] /* steps */
      } /* join_preparation */
    },
    {
      &amp;quot;join_optimization&amp;quot;: {			--SQL优化阶段
        &amp;quot;select#&amp;quot;: 1,
        &amp;quot;steps&amp;quot;: [
          {
            &amp;quot;condition_processing&amp;quot;: {    --条件处理
              &amp;quot;condition&amp;quot;: &amp;quot;WHERE&amp;quot;,
              &amp;quot;original_condition&amp;quot;: &amp;quot;((`t1`.`a` &amp;gt; 900) and (`t1`.`b` &amp;gt; 910))&amp;quot;,        --原始条件
              &amp;quot;steps&amp;quot;: [
                {
                  &amp;quot;transformation&amp;quot;: &amp;quot;equality_propagation&amp;quot;,
                  &amp;quot;resulting_condition&amp;quot;: &amp;quot;((`t1`.`a` &amp;gt; 900) and (`t1`.`b` &amp;gt; 910))&amp;quot; 		--等值传递转换
                },
                {
                  &amp;quot;transformation&amp;quot;: &amp;quot;constant_propagation&amp;quot;,
                  &amp;quot;resulting_condition&amp;quot;: &amp;quot;((`t1`.`a` &amp;gt; 900) and (`t1`.`b` &amp;gt; 910))&amp;quot;       --常量传递转换
                },
                {
                  &amp;quot;transformation&amp;quot;: &amp;quot;trivial_condition_removal&amp;quot;,
                  &amp;quot;resulting_condition&amp;quot;: &amp;quot;((`t1`.`a` &amp;gt; 900) and (`t1`.`b` &amp;gt; 910))&amp;quot;        --去除没有的条件后的结构
                }
              ] /* steps */
            } /* condition_processing */
          },
          {
            &amp;quot;substitute_generated_columns&amp;quot;: {
            } /* substitute_generated_columns */   --替换虚拟生成列
          },
          {
            &amp;quot;table_dependencies&amp;quot;: [		--表依赖详情
              {
                &amp;quot;table&amp;quot;: &amp;quot;`t1`&amp;quot;,
                &amp;quot;row_may_be_null&amp;quot;: false,
                &amp;quot;map_bit&amp;quot;: 0,
                &amp;quot;depends_on_map_bits&amp;quot;: [
                ] /* depends_on_map_bits */
              }
            ] /* table_dependencies */
          },
          {
            &amp;quot;ref_optimizer_key_uses&amp;quot;: [
            ] /* ref_optimizer_key_uses */
          },
          {
            &amp;quot;rows_estimation&amp;quot;: [	--预估表的访问成本
              {
                &amp;quot;table&amp;quot;: &amp;quot;`t1`&amp;quot;,
                &amp;quot;range_analysis&amp;quot;: {
                  &amp;quot;table_scan&amp;quot;: {
                    &amp;quot;rows&amp;quot;: 1000,       --扫描行数
                    &amp;quot;cost&amp;quot;: 207.1       --成本
                  } /* table_scan */,
                  &amp;quot;potential_range_indexes&amp;quot;: [    --分析可能使用的索引
                    {
                      &amp;quot;index&amp;quot;: &amp;quot;PRIMARY&amp;quot;,
                      &amp;quot;usable&amp;quot;: false,       --为false，说明主键索引不可用
                      &amp;quot;cause&amp;quot;: &amp;quot;not_applicable&amp;quot;
                    },
                    {
                      &amp;quot;index&amp;quot;: &amp;quot;idx_a&amp;quot;,      --可能使用索引idx_a
                      &amp;quot;usable&amp;quot;: true,
                      &amp;quot;key_parts&amp;quot;: [
                        &amp;quot;a&amp;quot;,
                        &amp;quot;id&amp;quot;
                      ] /* key_parts */
                    },
                    {
                      &amp;quot;index&amp;quot;: &amp;quot;idx_b&amp;quot;,      --可能使用索引idx_b
                      &amp;quot;usable&amp;quot;: true,
                      &amp;quot;key_parts&amp;quot;: [
                        &amp;quot;b&amp;quot;,
                        &amp;quot;id&amp;quot;
                      ] /* key_parts */
                    }
                  ] /* potential_range_indexes */,
                  &amp;quot;setup_range_conditions&amp;quot;: [
                  ] /* setup_range_conditions */,
                  &amp;quot;group_index_range&amp;quot;: {
                    &amp;quot;chosen&amp;quot;: false,
                    &amp;quot;cause&amp;quot;: &amp;quot;not_group_by_or_distinct&amp;quot;
                  } /* group_index_range */,
                  &amp;quot;analyzing_range_alternatives&amp;quot;: { --分析各索引的成本
                    &amp;quot;range_scan_alternatives&amp;quot;: [
                      {
                        &amp;quot;index&amp;quot;: &amp;quot;idx_a&amp;quot;,	--使用索引idx_a的成本
                        &amp;quot;ranges&amp;quot;: [
                          &amp;quot;900 &amp;lt; a&amp;quot;			--使用索引idx_a的范围
                        ] /* ranges */,
                        &amp;quot;index_dives_for_eq_ranges&amp;quot;: true, --是否使用index dive（详细描述请看下方的知识扩展）
                        &amp;quot;rowid_ordered&amp;quot;: false, --使用该索引获取的记录是否按照主键排序
                        &amp;quot;using_mrr&amp;quot;: false,  	--是否使用mrr
                        &amp;quot;index_only&amp;quot;: false,    --是否使用覆盖索引
                        &amp;quot;rows&amp;quot;: 100,            --使用该索引获取的记录数
                        &amp;quot;cost&amp;quot;: 121.01,         --使用该索引的成本
                        &amp;quot;chosen&amp;quot;: true          --可能选择该索引
                      },
                      {
                        &amp;quot;index&amp;quot;: &amp;quot;idx_b&amp;quot;,       --使用索引idx_b的成本
                        &amp;quot;ranges&amp;quot;: [
                          &amp;quot;910 &amp;lt; b&amp;quot;
                        ] /* ranges */,
                        &amp;quot;index_dives_for_eq_ranges&amp;quot;: true,
                        &amp;quot;rowid_ordered&amp;quot;: false,
                        &amp;quot;using_mrr&amp;quot;: false,
                        &amp;quot;index_only&amp;quot;: false,
                        &amp;quot;rows&amp;quot;: 90,
                        &amp;quot;cost&amp;quot;: 109.01,
                        &amp;quot;chosen&amp;quot;: true             --也可能选择该索引
                      }
                    ] /* range_scan_alternatives */,
                    &amp;quot;analyzing_roworder_intersect&amp;quot;: { --分析使用索引合并的成本
                      &amp;quot;usable&amp;quot;: false,
                      &amp;quot;cause&amp;quot;: &amp;quot;too_few_roworder_scans&amp;quot;
                    } /* analyzing_roworder_intersect */
                  } /* analyzing_range_alternatives */,
                  &amp;quot;chosen_range_access_summary&amp;quot;: {  --确认最优方法
                    &amp;quot;range_access_plan&amp;quot;: {
                      &amp;quot;type&amp;quot;: &amp;quot;range_scan&amp;quot;,
                      &amp;quot;index&amp;quot;: &amp;quot;idx_b&amp;quot;,
                      &amp;quot;rows&amp;quot;: 90,
                      &amp;quot;ranges&amp;quot;: [
                        &amp;quot;910 &amp;lt; b&amp;quot;
                      ] /* ranges */
                    } /* range_access_plan */,
                    &amp;quot;rows_for_plan&amp;quot;: 90,
                    &amp;quot;cost_for_plan&amp;quot;: 109.01,
                    &amp;quot;chosen&amp;quot;: true
                  } /* chosen_range_access_summary */
                } /* range_analysis */
              }
            ] /* rows_estimation */
          },
          {
            &amp;quot;considered_execution_plans&amp;quot;: [  --考虑的执行计划
              {
                &amp;quot;plan_prefix&amp;quot;: [
                ] /* plan_prefix */,
                &amp;quot;table&amp;quot;: &amp;quot;`t1`&amp;quot;,
                &amp;quot;best_access_path&amp;quot;: {          --最优的访问路径
                  &amp;quot;considered_access_paths&amp;quot;: [ --决定的访问路径
                    {
                      &amp;quot;rows_to_scan&amp;quot;: 90,      --扫描的行数
                      &amp;quot;access_type&amp;quot;: &amp;quot;range&amp;quot;,  --访问类型：为range
                      &amp;quot;range_details&amp;quot;: {
                        &amp;quot;used_index&amp;quot;: &amp;quot;idx_b&amp;quot;  --使用的索引为：idx_b
                      } /* range_details */,
                      &amp;quot;resulting_rows&amp;quot;: 90,    --结果行数
                      &amp;quot;cost&amp;quot;: 127.01,          --成本
                      &amp;quot;chosen&amp;quot;: true,		   --确定选择
                      &amp;quot;use_tmp_table&amp;quot;: true
                    }
                  ] /* considered_access_paths */
                } /* best_access_path */,
                &amp;quot;condition_filtering_pct&amp;quot;: 100,
                &amp;quot;rows_for_plan&amp;quot;: 90,
                &amp;quot;cost_for_plan&amp;quot;: 127.01,
                &amp;quot;sort_cost&amp;quot;: 90,
                &amp;quot;new_cost_for_plan&amp;quot;: 217.01,
                &amp;quot;chosen&amp;quot;: true
              }
            ] /* considered_execution_plans */
          },
          {
            &amp;quot;attaching_conditions_to_tables&amp;quot;: {  --尝试添加一些其他的查询条件
              &amp;quot;original_condition&amp;quot;: &amp;quot;((`t1`.`a` &amp;gt; 900) and (`t1`.`b` &amp;gt; 910))&amp;quot;,
              &amp;quot;attached_conditions_computation&amp;quot;: [
              ] /* attached_conditions_computation */,
              &amp;quot;attached_conditions_summary&amp;quot;: [
                {
                  &amp;quot;table&amp;quot;: &amp;quot;`t1`&amp;quot;,
                  &amp;quot;attached&amp;quot;: &amp;quot;((`t1`.`a` &amp;gt; 900) and (`t1`.`b` &amp;gt; 910))&amp;quot;
                }
              ] /* attached_conditions_summary */
            } /* attaching_conditions_to_tables */
          },
          {
            &amp;quot;clause_processing&amp;quot;: {
              &amp;quot;clause&amp;quot;: &amp;quot;ORDER BY&amp;quot;,
              &amp;quot;original_clause&amp;quot;: &amp;quot;`t1`.`a`&amp;quot;,
              &amp;quot;items&amp;quot;: [
                {
                  &amp;quot;item&amp;quot;: &amp;quot;`t1`.`a`&amp;quot;
                }
              ] /* items */,
              &amp;quot;resulting_clause_is_simple&amp;quot;: true,
              &amp;quot;resulting_clause&amp;quot;: &amp;quot;`t1`.`a`&amp;quot;
            } /* clause_processing */
          },
          {
            &amp;quot;reconsidering_access_paths_for_index_ordering&amp;quot;: {
              &amp;quot;clause&amp;quot;: &amp;quot;ORDER BY&amp;quot;,
              &amp;quot;index_order_summary&amp;quot;: {
                &amp;quot;table&amp;quot;: &amp;quot;`t1`&amp;quot;,
                &amp;quot;index_provides_order&amp;quot;: false,
                &amp;quot;order_direction&amp;quot;: &amp;quot;undefined&amp;quot;,
                &amp;quot;index&amp;quot;: &amp;quot;idx_b&amp;quot;,
                &amp;quot;plan_changed&amp;quot;: false
              } /* index_order_summary */
            } /* reconsidering_access_paths_for_index_ordering */
          },
          {
            &amp;quot;refine_plan&amp;quot;: [          --改进的执行计划
              {
                &amp;quot;table&amp;quot;: &amp;quot;`t1`&amp;quot;,
                &amp;quot;pushed_index_condition&amp;quot;: &amp;quot;(`t1`.`b` &amp;gt; 910)&amp;quot;,
                &amp;quot;table_condition_attached&amp;quot;: &amp;quot;(`t1`.`a` &amp;gt; 900)&amp;quot;
              }
            ] /* refine_plan */
          }
        ] /* steps */
      } /* join_optimization */
    },
    {
      &amp;quot;join_execution&amp;quot;: {             --SQL执行阶段
        &amp;quot;select#&amp;quot;: 1,
        &amp;quot;steps&amp;quot;: [
          {
            &amp;quot;filesort_information&amp;quot;: [
              {
                &amp;quot;direction&amp;quot;: &amp;quot;asc&amp;quot;,
                &amp;quot;table&amp;quot;: &amp;quot;`t1`&amp;quot;,
                &amp;quot;field&amp;quot;: &amp;quot;a&amp;quot;
              }
            ] /* filesort_information */,
            &amp;quot;filesort_priority_queue_optimization&amp;quot;: {
              &amp;quot;usable&amp;quot;: false,             --未使用优先队列优化排序
              &amp;quot;cause&amp;quot;: &amp;quot;not applicable (no LIMIT)&amp;quot;     --未使用优先队列排序的原因是没有limit
            } /* filesort_priority_queue_optimization */,
            &amp;quot;filesort_execution&amp;quot;: [
            ] /* filesort_execution */,
            &amp;quot;filesort_summary&amp;quot;: {           --排序详情
              &amp;quot;rows&amp;quot;: 90,
              &amp;quot;examined_rows&amp;quot;: 90,          --参与排序的行数
              &amp;quot;number_of_tmp_files&amp;quot;: 0,     --排序过程中使用的临时文件数
              &amp;quot;sort_buffer_size&amp;quot;: 115056,
              &amp;quot;sort_mode&amp;quot;: &amp;quot;&amp;lt;sort_key, additional_fields&amp;gt;&amp;quot;   --排序模式（详解请看下方知识扩展）
            } /* filesort_summary */
          }
        ] /* steps */
      } /* join_execution */
    }
  ] /* steps */
}
MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0	--该字段表示分析过程丢弃的文本字节大小，本例为0，说明没丢弃任何文本
          INSUFFICIENT_PRIVILEGES: 0    --查看trace的权限是否不足，0表示有权限查看trace详情
1 row in set (0.00 sec)
------------------------------------------------
------------------------------------------------


mysql&amp;gt; set session optimizer_trace=&amp;quot;enabled=off&amp;quot;;
/* 及时关闭trace */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里对上方的执行字段详细描述一下：&lt;/p&gt;
&lt;p&gt;TRACE 字段中整个文本大致分为三个过程。&lt;/p&gt;
&lt;p&gt;准备阶段：对应文本中的 join_preparation&lt;br&gt;
优化阶段：对应文本中的 join_optimization&lt;br&gt;
执行阶段：对应文本中的 join_execution&lt;br&gt;
使用时，重点关注优化阶段和执行阶段。&lt;/p&gt;
&lt;p&gt;由此例可以看出：&lt;/p&gt;
&lt;p&gt;在 trace 结果的 analyzing_range_alternatives 这一项可以看到：使用索引 idx_a 的成本为 121.01，使用索引 idx_b 的成本为 109.01，显然使用索引 idx_b 的成本要低些，因此优化器选择了 idx_b 索引；&lt;br&gt;
在 trace 结果的 filesort_summary 这一项可以看到：排序模式为&amp;lt;sort_key, additional_fields&amp;gt;，表示使用的是单路排序，即一次性取出满足条件行的所有字段，然后在 sort buffer 中进行排序。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;知识扩展：

知识点一：MySQL 常见排序模式：

&amp;lt; sort_key, rowid &amp;gt;双路排序（又叫回表排序模式）：是首先根据相应的条件取出相应的排序字段和可以直接定位行数据的行 ID，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；
&amp;lt; sort_key, additional_fields &amp;gt;单路排序：是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；
&amp;lt; sort_key, packed_additional_fields &amp;gt;打包数据排序模式：将 char 和 varchar 字段存到 sort buffer 中时，更加紧缩。
三种排序模式比较：

第二种模式相对第一种模式，避免了二次回表，可以理解为用空间换时间。由于 sort buffer 有限，如果需要查询的数据比较大的话，会增加磁盘排序时间，效率可能比第一种方式更低。

MySQL 提供了一个参数：max_length_for_sort_data，当“排序的键值对大小” &amp;gt; max_length_for_sort_data 时，MySQL 认为磁盘外部排序的 IO 效率不如回表的效率，会选择第一种排序模式；否则，会选择第二种模式。

第三种模式主要解决变长字符数据存储空间浪费的问题。

知识点二：优化器在估计符合条件的行数时有两个选择：

index diver：dive 到 index 中利用索引完成元组数的估算；特点是速度慢，但可以得到精确的值；
index statistics：使用索引的统计数值，进行估算；特点是速度快，但是值不一定准确。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-总结&#34;&gt;3 总结&lt;/h2&gt;
&lt;p&gt;今天我们分享了 show profile 和 trace 的使用方法，我们来对比一下三种分析 SQL 方法的特点：&lt;/p&gt;
&lt;p&gt;explain：获取 MySQL 中 SQL 语句的执行计划，比如语句是否使用了关联查询、是否使用了索引、扫描行数等；&lt;br&gt;
profile：可以清楚了解到SQL到底慢在哪个环节；&lt;br&gt;
trace：查看优化器如何选择执行计划，获取每个可能的索引选择的代价。&lt;br&gt;
三种方法各有其适用场景，如果你有其它分析 SQL 的工具，欢迎在留言区分享。&lt;/p&gt;
&lt;p&gt;4 问题&lt;br&gt;
在工作中，遇到慢查询你是如何去分析优化的？&lt;/p&gt;
">快速学会分析SQL执行效率（下）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/2XXuytX6c/"" data-c="
          &lt;p&gt;从开篇词我们了解到，本专栏首先会一起讨论一下 SQL 优化，而优化 SQL 的前提是能定位到慢 SQL 并对其进行分析，因此在专栏的开始，会跟大家分享如何定位慢查询和如何分析 SQl 执行效率。在前面两节，会用一些简单的例子让大家学会这些分析技巧。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;在工作中可能会遇到某个新功能在测试时需要很久才返回结果，这时就应该分析是不是慢查询导致的。如果确实有慢查询，又应该怎么去分析 SQL 执行效率呢？这一篇文章我们就来学习怎么找到慢查询和怎么分析 SQL 执行效率。&lt;/p&gt;
&lt;p&gt;1 定位慢 SQL&lt;br&gt;
当我们实际工作中，碰到某个功能或者某个接口需要很久才能返回结果，我们就应该去确定是不是慢查询导致的。定位慢 SQL 有如下两种解决方案：&lt;/p&gt;
&lt;p&gt;查看慢查询日志确定已经执行完的慢查询&lt;br&gt;
show processlist 查看正在执行的慢查询&lt;br&gt;
我们一起来了解下这两种方法的使用场景和使用技巧吧！&lt;/p&gt;
&lt;p&gt;1.1 通过慢查询日志&lt;br&gt;
如果需要定位到慢查询，一般的方法是通过慢查询日志来查询的，MySQL 的慢查询日志用来记录在 MySQL 中响应时间超过参数 long_query_time（单位秒，默认值 10）设置的值并且扫描记录数不小于 min_examined_row_limit（默认值0）的语句，能够帮我们找到执行完的慢查询，方便我们对这些 SQL 进行优化。&lt;/p&gt;
&lt;p&gt;知识扩展：&lt;/p&gt;
&lt;p&gt;默认情况下，慢查询日志中不会记录管理语句，可通过设置 log_slow_admin_statements = on 让管理语句中的慢查询也会记录到慢查询日志中。&lt;/p&gt;
&lt;p&gt;默认情况下，也不会记录查询时间不超过 long_query_time 但是不使用索引的语句，可通过配置log_queries_not_using_indexes = on 让不使用索引的 SQL 都被记录到慢查询日志中（即使查询时间没超过 long_query_time 配置的值）。&lt;/p&gt;
&lt;p&gt;如果需要使用慢查询日志，一般分为四步：开启慢查询日志、设置慢查询阀值、确定慢查询日志路径、确定慢查询日志的文件名。下面我们来学习下:&lt;/p&gt;
&lt;p&gt;首先开启慢查询日志，由参数 slow_query_log 决定是否开启，在 MySQL 命令行下输入下面的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; set global slow_query_log = on;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认环境下，慢查询日志是关闭的。&lt;/p&gt;
&lt;p&gt;设置慢查询时间阀值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; set global long_query_time = 1;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;知识扩展：
MySQL 中 long_query_time 的值如何确定呢？

线上业务一般建议把 long_query_time 设置为 1 秒，如果某个业务的 MySQL 要求比较高的 QPS，可设置慢查询为 0.1 秒。发现慢查询及时优化或者提醒开发改写。

一般测试环境建议 long_query_time 设置的阀值比生产环境的小，比如生产环境是 1 秒，则测试环境建议配置成 0.5 秒。便于在测试环境及时发现一些效率低的 SQL。

甚至某些重要业务测试环境 long_query_time 可以设置为 0，以便记录所有语句。并留意慢查询日志的输出，上线前的功能测试完成后，分析慢查询日志每类语句的输出，重点关注 Rows_examined（语句执行期间从存储引擎读取的行数），提前优化。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;确定慢查询日志路径&lt;/p&gt;
&lt;p&gt;慢查询日志的路径默认是 MySQL 的数据目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show global variables like &amp;quot;datadir&amp;quot;;

+---------------+------------------------+
| Variable_name | Value                  |
+---------------+------------------------+
| datadir       | /data/mysql/data/3306/ |
+---------------+------------------------+

1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;确定慢查询日志的文件名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show global variables like &amp;quot;slow_query_log_file&amp;quot;;

+---------------------+----------------+
| Variable_name       | Value          |
+---------------------+----------------+
| slow_query_log_file | mysql-slow.log |
+---------------------+----------------+

1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据上面的查询结果，可以直接查看 /data/mysql/data/3306/mysql-slow.log 文件获取已经执行完的慢查询&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@mysqltest ~]# tail -n5 /data/mysql/data/3306/mysql-slow.log

Time: 2019-05-21T09:15:06.255554+08:00

User@Host: root[root] @ localhost []  Id: 8591152

Query_time: 10.000260  Lock_time: 0.000000 Rows_sent: 1  Rows_examined: 0

SET timestamp=1558401306;
select sleep(10);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里对上方的执行结果详细描述一下：&lt;/p&gt;
&lt;p&gt;tail -n5：只查看慢查询文件的最后5行&lt;br&gt;
Time：慢查询发生的时间&lt;br&gt;
User@Host：客户端用户和IP&lt;br&gt;
Query_time：查询时间&lt;br&gt;
Lock_time：等待表锁的时间&lt;br&gt;
Rows_sent：语句返回的行数&lt;br&gt;
Rows_examined：语句执行期间从存储引擎读取的行数&lt;br&gt;
上面这种方式是用系统自带的慢查询日志查看的，如果觉得系统自带的慢查询日志不方便查看，小伙伴们可以使用 pt-query-digest 或者 mysqldumpslow 等工具对慢查询日志进行分析，由于本节重点是找到慢查询，这里就不一一示例了。&lt;/p&gt;
&lt;p&gt;1.2 通过 show processlist;&lt;br&gt;
有时慢查询正在执行，已经导致数据库负载偏高了，而由于慢查询还没执行完，因此慢查询日志还看不到任何语句。此时可以使用 show processlist 命令判断正在执行的慢查询。show processlist 显示哪些线程正在运行。如果有 PROCESS 权限，则可以看到所有线程。否则，只能看到当前会话的线程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;知识扩展：如果不使用 FULL 关键字，在 info 字段中只显示每个语句的前 100 个字符，如果想看语句的全部内容可以使用 full 修饰（show full processlist）。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show processlist\G`

`......`

`*************************** 10. row ***************************`

     `Id: 7651833`

   `User: one`

   `Host: 192.168.1.251:52154`

     `db: ops`

`Command: Query`

   `Time: 3`

  `State: User sleep`

   `Info: select sleep(10)`

`......`

`10 rows in set (0.00 sec)`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里对上面结果解释一下：&lt;/p&gt;
&lt;p&gt;Time：表示执行时间&lt;br&gt;
Info：表示 SQL 语句&lt;br&gt;
我们这里可以通过它的执行时间（Time）来判断是否是慢 SQL。&lt;/p&gt;
&lt;p&gt;2 使用 explain 分析慢查询&lt;br&gt;
分析 SQL 执行效率是优化 SQL 的重要手段，通过上面讲的两种方法，定位到慢查询语句后，我们就要开始分析 SQL 执行效率了，子曾经曰过：“工欲善其事，必先利其器”，我们可以通过 explain、show profile 和 trace 等诊断工具来分析慢查询。本节先讲解 explain 的使用，在下节将分享 show profile 和 trace 的使用。&lt;/p&gt;
&lt;p&gt;Explain 可以获取 MySQL 中 SQL 语句的执行计划，比如语句是否使用了关联查询、是否使用了索引、扫描行数等。可以帮我们选择更好地索引和写出更优的 SQL 。使用方法：在查询语句前面加上 explain 运行就可以了。&lt;/p&gt;
&lt;p&gt;这也是分析 SQL 时最常用的，也是作者最推荐的一种分析慢查询的方式。下面我们来看下示例~~&lt;/p&gt;
&lt;p&gt;为了便于理解，先创建两张测试表（方便第 1、2 节实验使用），建表及数据写入语句如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE DATABASE muke;           /* 创建测试使用的database，名为muke */
use muke;                       /* 使用muke这个database */
drop table if exists t1;        /* 如果表t1存在则删除表t1 */

CREATE TABLE `t1` (             /* 创建表t1 */
  `id` int(11) NOT NULL auto_increment,
  `a` int(11) DEFAULT NULL,
  `b` int(11) DEFAULT NULL,
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;记录创建时间&#39;,
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;记录更新时间&#39;,
  PRIMARY KEY (`id`),
  KEY `idx_a` (`a`),
  KEY `idx_b` (`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;	

drop procedure if exists insert_t1; /* 如果存在存储过程insert_t1，则删除 */
delimiter ;;
create procedure insert_t1()        /* 创建存储过程insert_t1 */
begin
  declare i int;                    /* 声明变量i */
  set i=1;                          /* 设置i的初始值为1 */
  while(i&amp;lt;=1000)do                  /* 对满足i&amp;lt;=1000的值进行while循环 */
    insert into t1(a,b) values(i, i); /* 写入表t1中a、b两个字段，值都为i当前的值 */
    set i=i+1;                      /* 将i加1 */
  end while;
end;;
delimiter ;                 /* 创建批量写入1000条数据到表t1的存储过程insert_t1 */
call insert_t1();           /* 运行存储过程insert_t1 */

drop table if exists t2;    /* 如果表t2存在则删除表t2 */
create table t2 like t1;    /* 创建表t2，表结构与t1一致 */
insert into t2 select * from t1;   /* 将表t1的数据导入到t2 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面尝试使用 explain 分析一条 SQL，例子如下：&lt;br&gt;
&lt;code&gt;mysql&amp;gt; explain select * from t1 where b=100;&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1599389745198.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图片描述Explain 的结果各字段解释如下：&lt;/p&gt;
&lt;p&gt;加粗的列为需要重点关注的项。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;列名	解释
id	查询编号
select_type	查询类型：显示本行是简单还是复杂查询
table	涉及到的表
partitions	匹配的分区：查询将匹配记录所在的分区。仅当使用 partition 关键字时才显示该列。对于非分区表，该值为 NULL。
type	本次查询的表连接类型
possible_keys	可能选择的索引
key	实际选择的索引
key_len	被选择的索引长度：一般用于判断联合索引有多少列被选择了
ref	与索引比较的列
rows	预计需要扫描的行数，对 InnoDB 来说，这个值是估值，并不一定准确
filtered	按条件筛选的行的百分比
Extra	附加信息
表1-explain 各字段解释
其中 explain 各列都有各种不同的值，这里介绍几个比较重要列常包含的值:包含 select_typ、type 和 Extra。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面将列出它们常见的一些值，可稍微过一遍，不需要完全记下来，在后续章节分析 SQL 时，可以返回查询本节内容并对比各种值的区别。&lt;/p&gt;
&lt;p&gt;2.1 select_type&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select_type 的值	解释
SIMPLE	简单查询(不使用关联查询或子查询)
PRIMARY	如果包含关联查询或者子查询，则最外层的查询部分标记为primary
UNION	联合查询中第二个及后面的查询
DEPENDENT UNION	满足依赖外部的关联查询中第二个及以后的查询
UNION RESULT	联合查询的结果
SUBQUERY	子查询中的第一个查询
DEPENDENT SUBQUERY	子查询中的第一个查询，并且依赖外部查询
DERIVED	用到派生表的查询
MATERIALIZED	被物化的子查询
UNCACHEABLE SUBQUERY	一个子查询的结果不能被缓存，必须重新评估外层查询的每一行
UNCACHEABLE UNION	关联查询第二个或后面的语句属于不可缓存的子查询
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表2-select_type 各项值解释&lt;br&gt;
2.2 type&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type的值	解释
system	查询对象表只有一行数据,且只能用于 MyISAM 和 Memory 引擎的表，这是最好的情况
const	基于主键或唯一索引查询，最多返回一条结果
eq_ref	表连接时基于主键或非 NULL 的唯一索引完成扫描
ref	基于普通索引的等值查询，或者表间等值连接
fulltext	全文检索
ref_or_null	表连接类型是 ref，但进行扫描的索引列中可能包含 NULL 值
index_merge	利用多个索引
unique_subquery	子查询中使用唯一索引
index_subquery	子查询中使用普通索引
range	利用索引进行范围查询
index	全索引扫描
ALL	全表扫描
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表3-type 各项值解释&lt;br&gt;
上表的这些情况，查询性能从上到下依次是最好到最差。&lt;/p&gt;
&lt;p&gt;2.3 Extra&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Extra 常见的值	解释	例子
Using filesort	将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序	explain select * from t1 order by create_time;
Using temporary	需要创建一个临时表来存储结构，通常发生对没有索引的列进行 GROUP BY 时	explain select * from t1 group by create_time;
Using index	使用覆盖索引	explain select a from t1 where a=111;
Using where	使用 where 语句来处理结果	explain select * from t1 where create_time=‘2019-06-18 14:38:24’;
Impossible WHERE	对 where 子句判断的结果总是 false 而不能选择任何数据	explain select * from t1 where 1&amp;lt;0;
Using join buffer (Block Nested Loop)	关联查询中，被驱动表的关联字段没索引	explain select * from t1 straight_join t2 on (t1.create_time=t2.create_time);
Using index condition	先条件过滤索引，再查数据	explain select * from t1 where a &amp;gt;900 and a like “%9”;
Select tables optimized away	使用某些聚合函数（比如 max、min）来访问存在索引的某个字段是	explain select max(a) from t1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表4-Extra 常见值解释及举例&lt;br&gt;
3 总结&lt;br&gt;
今天我分享的关于定位慢 SQL 及使用 explain 分析慢 SQL 到这里就结束了。本节知识点总结如下：&lt;/p&gt;
&lt;p&gt;本节首先讲到如何定位慢 SQL:&lt;/p&gt;
&lt;p&gt;一种方法是查看慢查询日志&lt;br&gt;
另一种方法是 show process 查看正在执行的 SQL&lt;br&gt;
再讲到通过 explain 分析慢 SQL，explain 会返回很多字段，其中 select_type、type、key、rows、Extra 是重点关注项。&lt;/p&gt;
&lt;p&gt;在工作中及面试时，SQL 性能优化都是我们经常遇到的问题，要想做好性能优化，我们必须学会使用 SQL 优化时需要的工具，进行定位和分析。由于篇幅的问题，本小节只介绍了 explain 工具的使用，在下节将补充另外两种分析慢查询的工具：show profile 和 trace。在后面我会再讲解 SQL 优化的一些知识点，相信小伙伴们 SQL 性能优化时一定可以越来越熟练。&lt;/p&gt;
&lt;p&gt;最后小伙伴们可以将处理问题时的心得体会进行总结，也欢迎给我留言分享，我们一起来交流、学习、进步。&lt;/p&gt;
&lt;p&gt;4 问题&lt;br&gt;
你在平常工作中是怎么降低慢查询在生产环境出现的概率？&lt;/p&gt;
">快速学会分析SQL执行效率</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/cifMT6byw/"" data-c="
          &lt;p&gt;1 消息&lt;br&gt;
▪ 100 Continue&lt;br&gt;
▪ 101 Switching Protocols&lt;br&gt;
▪ 102 Processing&lt;br&gt;
2 成功&lt;br&gt;
▪ 200 OK&lt;br&gt;
▪ 201 Created&lt;br&gt;
▪ 202 Accepted&lt;br&gt;
▪ 203 Non-Authoritative Information&lt;br&gt;
▪ 204 No Content&lt;br&gt;
▪ 205 Reset Content&lt;br&gt;
▪ 206 Partial Content&lt;br&gt;
▪ 207 Multi-Status&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;3 重定向&lt;br&gt;
▪ 300 Multiple Choices&lt;br&gt;
▪ 301 Moved Permanently&lt;br&gt;
▪ 302 Move temporarily&lt;br&gt;
▪ 303 See Other&lt;br&gt;
▪ 304 Not Modified&lt;br&gt;
▪ 305 Use Proxy&lt;br&gt;
▪ 306 Switch Proxy&lt;br&gt;
▪ 307 Temporary Redirect&lt;br&gt;
4 请求错误&lt;br&gt;
▪ 400 Bad Request&lt;br&gt;
▪ 401 Unauthorized&lt;br&gt;
▪ 402 Payment Required&lt;br&gt;
▪ 403 Forbidden&lt;br&gt;
▪ 404 Not Found&lt;br&gt;
▪ 405 Method Not Allowed&lt;br&gt;
▪ 406 Not Acceptable&lt;br&gt;
▪ 407 Proxy Authentication Required&lt;br&gt;
▪ 408 Request Timeout&lt;br&gt;
▪ 409 Conflict&lt;br&gt;
▪ 410 Gone&lt;br&gt;
▪ 411 Length Required&lt;br&gt;
▪ 412 Precondition Failed&lt;br&gt;
▪ 413 Request Entity Too Large&lt;br&gt;
▪ 414 Request-URI Too Long&lt;br&gt;
▪ 415 Unsupported Media Type&lt;br&gt;
▪ 416 Requested Range Not Satisfiable&lt;br&gt;
▪ 417 Expectation Failed&lt;br&gt;
▪ 421 too many connections&lt;br&gt;
▪ 422 Unprocessable Entity&lt;br&gt;
▪ 423 Locked&lt;br&gt;
▪ 424 Failed Dependency&lt;br&gt;
▪ 425 Unordered Collection&lt;br&gt;
▪ 426 Upgrade Required&lt;br&gt;
▪ 449 Retry With&lt;br&gt;
▪ 451Unavailable For Legal Reasons&lt;br&gt;
5 服务器错误&lt;br&gt;
▪ 500 Internal Server Error&lt;br&gt;
▪ 501 Not Implemented&lt;br&gt;
▪ 502 Bad Gateway&lt;br&gt;
▪ 503 Service Unavailable&lt;br&gt;
▪ 504 Gateway Timeout&lt;br&gt;
▪ 505 HTTP Version Not Supported&lt;br&gt;
▪ 506 Variant Also Negotiates&lt;br&gt;
▪ 507 Insufficient Storage&lt;br&gt;
▪ 509 Bandwidth Limit Exceeded&lt;br&gt;
▪ 510 Not Extended&lt;br&gt;
▪ 600 Unparseable Response Headers&lt;/p&gt;
&lt;p&gt;100 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。&lt;/p&gt;
&lt;p&gt;101 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 　　只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。&lt;/p&gt;
&lt;p&gt;102 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。&lt;/p&gt;
&lt;p&gt;200 请求已成功，请求所希望的响应头或数据体将随此响应返回。&lt;/p&gt;
&lt;p&gt;201 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 &#39;202 Accepted&#39;。&lt;/p&gt;
&lt;p&gt;202 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 　　返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。&lt;/p&gt;
&lt;p&gt;203 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。&lt;/p&gt;
&lt;p&gt;204 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 　　如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 　　由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。&lt;/p&gt;
&lt;p&gt;205 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 　　与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。&lt;/p&gt;
&lt;p&gt;206 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 　　该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 　　响应必须包含如下的头部域： 　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 　　Date 　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。&lt;/p&gt;
&lt;p&gt;207 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。&lt;/p&gt;
&lt;p&gt;300 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 　　除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 　　如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。&lt;/p&gt;
&lt;p&gt;301 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 　　新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。&lt;/p&gt;
&lt;p&gt;302 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。&lt;/p&gt;
&lt;p&gt;303 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 　　新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。&lt;/p&gt;
&lt;p&gt;304 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 　　该响应必须包含以下的头信息： 　　Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 　　ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 　　Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 　　假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 　　假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。&lt;/p&gt;
&lt;p&gt;305 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 　　注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。&lt;/p&gt;
&lt;p&gt;306 在最新版的规范中，306状态码已经不再被使用。&lt;/p&gt;
&lt;p&gt;307 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 　　如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。&lt;/p&gt;
&lt;p&gt;400 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。&lt;/p&gt;
&lt;p&gt;401 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。&lt;/p&gt;
&lt;p&gt;402 该状态码是为了将来可能的需求而预留的。&lt;/p&gt;
&lt;p&gt;403 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。&lt;/p&gt;
&lt;p&gt;404 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。&lt;/p&gt;
&lt;p&gt;405 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。&lt;/p&gt;
&lt;p&gt;406 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 　　除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。&lt;/p&gt;
&lt;p&gt;407 　与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。&lt;/p&gt;
&lt;p&gt;408 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。&lt;/p&gt;
&lt;p&gt;409 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。&lt;/p&gt;
&lt;p&gt;410 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 　　410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为&#39;410 Gone&#39;，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。&lt;/p&gt;
&lt;p&gt;411 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。&lt;/p&gt;
&lt;p&gt;412 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。&lt;/p&gt;
&lt;p&gt;413 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。&lt;/p&gt;
&lt;p&gt;414 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 　　本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 　　重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 　　客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。&lt;/p&gt;
&lt;p&gt;415 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。&lt;/p&gt;
&lt;p&gt;416 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 　　假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。&lt;/p&gt;
&lt;p&gt;417 在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。&lt;/p&gt;
&lt;p&gt;421 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。&lt;/p&gt;
&lt;p&gt;422 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。&lt;/p&gt;
&lt;p&gt;422 请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 　　当前资源被锁定。（RFC 4918 WebDAV）&lt;/p&gt;
&lt;p&gt;424 由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）&lt;/p&gt;
&lt;p&gt;425 在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。&lt;/p&gt;
&lt;p&gt;426 客户端应当切换到TLS/1.0。（RFC 2817）&lt;/p&gt;
&lt;p&gt;449 由微软扩展，代表请求应当在执行完适当的操作后进行重试。&lt;/p&gt;
&lt;p&gt;500 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。&lt;/p&gt;
&lt;p&gt;501 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。&lt;/p&gt;
&lt;p&gt;502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。&lt;/p&gt;
&lt;p&gt;503 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 　　注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。&lt;/p&gt;
&lt;p&gt;504 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 　　注意：某些代理服务器在DNS查询超时时会返回400或者500错误&lt;/p&gt;
&lt;p&gt;505 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。&lt;/p&gt;
&lt;p&gt;506 由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。&lt;/p&gt;
&lt;p&gt;507 服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)&lt;/p&gt;
&lt;p&gt;509 服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。&lt;/p&gt;
&lt;p&gt;510 获取资源所需要的策略并没有没满足。（RFC 2774）&lt;/p&gt;
">HTTPS状态码</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/Vk-CNXac3/"" data-c="
          &lt;p&gt;strconv包是GO语言实现基本数据类型和字符串相互转换的包，常用函数有 &lt;code&gt;Atoi&lt;/code&gt;、&lt;code&gt;Itia()&lt;/code&gt;、&lt;code&gt;parse，format，append&lt;/code&gt;等系列函数&lt;/p&gt;
&lt;h2 id=&#34;字符串string和int类型转换&#34;&gt;字符串string和int类型转换&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Atoi&lt;/code&gt;&lt;br&gt;
此函数是将字符串类型的整数转换为int类型&lt;br&gt;
&lt;code&gt;func Atoi(s string)(i int ,err error)&lt;/code&gt;&lt;br&gt;
例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a := &amp;quot;100&amp;quot;
b,err:= strconv.Atoi(a)
if err !=nil{
        return true
}else{
        return false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Itoa()&lt;/code&gt;&lt;br&gt;
此函数是将int类型数据转换为对应的字符串表示&lt;br&gt;
&lt;code&gt;func Itoa(i int) string&lt;/code&gt;&lt;br&gt;
例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a := 200
v := strconv.Itoa(a)
fmt.Printf(&amp;quot;type:%T value:%#v\n&amp;quot;,a,v) //type:string value:&amp;quot;200&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;parse系列函数&#34;&gt;Parse系列函数&lt;/h2&gt;
&lt;p&gt;此类函数用于转换字符串为给定类型的值：&lt;code&gt;ParseBool(),ParseFloat(),ParseInt(),ParseUint()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;parsebool&#34;&gt;ParseBool()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;func ParseBool(str string) (value bool,err error)&lt;/code&gt;&lt;br&gt;
返回字符串表示的bool值，只接受1,0,t,f,T,F,true,false,True,False,TRUE,FALSE;否则返回错误&lt;/p&gt;
&lt;h3 id=&#34;parseint&#34;&gt;ParseInt()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;func ParseInt(s string,base int,bitSize int)(i int64,err error)&lt;/code&gt;&lt;br&gt;
返回字符串表示的整数值，接受正负号。&lt;/p&gt;
&lt;p&gt;base指定进制（2到36），如果base为0，则会从字符串前置判断，”0x”是16进制，”0”是8进制，否则是10进制；&lt;/p&gt;
&lt;p&gt;bitSize指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64；&lt;/p&gt;
&lt;p&gt;返回的err是*NumErr类型的，如果语法有误，err.Error = ErrSyntax；如果结果超出类型范围err.Error = ErrRange&lt;/p&gt;
&lt;h3 id=&#34;parseunit&#34;&gt;ParseUnit()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;func ParseUnit(s string,base int,bitSize int)(n uint64,err error)&lt;/code&gt;&lt;br&gt;
ParseUint类似ParseInt但不接受正负号，用于无符号整型。&lt;/p&gt;
&lt;h3 id=&#34;parsefloat&#34;&gt;ParseFloat()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;func ParseFloat(s string,bitSize int) (f float64,err error)&lt;/code&gt;&lt;br&gt;
解析一个表示浮点数的字符串并返回其值。&lt;br&gt;
如果s合乎语法规则，函数会返回最为接近s表示值的一个浮点数（使用IEEE754规范舍入）。&lt;br&gt;
bitSize指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64；&lt;br&gt;
返回值err是*NumErr类型的，语法有误的，err.Error=ErrSyntax；结果超出表示范围的，返回值f为±Inf，err.Error= ErrRange。&lt;br&gt;
例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;b, err := strconv.ParseBool(&amp;quot;true&amp;quot;)
f, err := strconv.ParseFloat(&amp;quot;3.1415&amp;quot;, 64)
i, err := strconv.ParseInt(&amp;quot;-2&amp;quot;, 10, 64)
u, err := strconv.ParseUint(&amp;quot;2&amp;quot;, 10, 64)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些函数都有两个返回值，第一个返回值是转换后的值，第二个返回值为转化失败的错误信息。&lt;/p&gt;
&lt;p&gt;###Format系列函数&lt;br&gt;
将给定类型数据格式化为string类型数据的功能。&lt;/p&gt;
&lt;h3 id=&#34;formatbool&#34;&gt;FormatBool()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;func FormatBool(b bool) string&lt;/code&gt;&lt;br&gt;
返回值“true”或“false”&lt;/p&gt;
&lt;h3 id=&#34;formatint&#34;&gt;FormatInt()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;func FormatInt(i int64,base int) string&lt;/code&gt;&lt;br&gt;
返回i的base进制的字符串表示。base必须在2到36之间，结果中会使用小写字母‘a’到‘z’表示大于10的数字&lt;/p&gt;
&lt;h3 id=&#34;formatuint&#34;&gt;FormatUint()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;func FormatUint( i uint64,base int) string&lt;/code&gt;&lt;br&gt;
是FormatInt的无符号整数版本。&lt;/p&gt;
&lt;h3 id=&#34;formatfloat&#34;&gt;FormatFloat()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;func FormatFloat(f float64, fmt byte, prec, bitSize int) string&lt;/code&gt;&lt;br&gt;
函数将浮点数表示为字符串并返回。&lt;br&gt;
bitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。&lt;br&gt;
fmt表示格式：’f’（-ddd.dddd）、’b’（-ddddp±ddd，指数为二进制）、’e’（-d.dddde±dd，十进制指数）、’E’（-d.ddddE±dd，十进制指数）、’g’（指数很大时用’e’格式，否则’f’格式）、’G’（指数很大时用’E’格式，否则’f’格式）。&lt;br&gt;
prec控制精度（排除指数部分）：对’f’、’e’、’E’，它表示小数点后的数字个数；对’g’、’G’，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。&lt;br&gt;
例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s1 := strconv.FormatBool(true)
s2 := strconv.FormatFloat(3.1415, &#39;E&#39;, -1, 64)
s3 := strconv.FormatInt(-2, 16)
s4 := strconv.FormatUint(2, 16)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;h3 id=&#34;isprint&#34;&gt;isPrint()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;func IsPrint(r rune) bool&lt;/code&gt;&lt;br&gt;
返回一个字符是否是可打印的，和unicode.IsPrint一样，r必须是：字母（广义）、数字、标点、符号、ASCII空格。&lt;/p&gt;
&lt;h3 id=&#34;canbackquote&#34;&gt;CanBackquote()&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;func CanBackquote(s string) bool&lt;/code&gt;&lt;br&gt;
返回字符串s是否可以不被修改的表示为一个单行的、没有空格和tab之外控制字符的反引号字符串。&lt;/p&gt;
&lt;p&gt;还有其他函数，具体查看&lt;a href=&#34;https://golang.org/pkg/strconv/&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
">GO strconv包</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/916fEKaXJ/"" data-c="
          &lt;p&gt;公司要做淘客类型的app,其中有个功能是要做分享海报的编辑，以前没有接触过，找了一些资料，历经几天的时间做了出来，下面分享我的代码，不好勿喷。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;视图&#34;&gt;视图&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
	&amp;lt;view&amp;gt;
        &amp;lt;canvas  canvas-id=&amp;quot;poster&amp;quot; &amp;gt;&amp;lt;/canvas&amp;gt;
        &amp;lt;image v-bind:src=&amp;quot;hbimg&amp;quot;&amp;gt;&amp;lt;/image&amp;gt;
    &amp;lt;/view&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;js&#34;&gt;js&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;  // 生成二维码
   import qr from &#39;@/common/wxqrcode.js&#39;
   // 文字换行
   function drawtext(text, maxWidth) {
   	let textArr = text.split(&amp;quot;&amp;quot;);
   	let len = textArr.length;
   	// 上个节点
   	let previousNode = 0;
   	// 记录节点宽度
   	let nodeWidth = 0;
   	// 文本换行数组
   	let rowText = [];
   	// 如果是字母，侧保存长度
   	let letterWidth = 0;
   	// 汉字宽度
   	let chineseWidth = 21;
   	// otherFont宽度
   	let otherWidth = 10.5;
   	for (let i = 0; i &amp;lt; len; i++) {
   		if (/[\u4e00-\u9fa5]|[\uFE30-\uFFA0]/g.test(textArr[i])) {
   			if(letterWidth &amp;gt; 0){
   				if(nodeWidth + chineseWidth + letterWidth * otherWidth &amp;gt; maxWidth){
   					rowText.push({
   						type: &amp;quot;text&amp;quot;,
   						content: text.substring(previousNode, i)
   					});
   					previousNode = i;
   					nodeWidth = chineseWidth;
   					letterWidth = 0;
   				} else {
   					nodeWidth += chineseWidth + letterWidth * otherWidth;
   					letterWidth = 0;
   				}
   			} else {
   				if(nodeWidth + chineseWidth &amp;gt; maxWidth){
   					rowText.push({
   						type: &amp;quot;text&amp;quot;,
   						content: text.substring(previousNode, i)
   					});
   					previousNode = i;
   					nodeWidth = chineseWidth;
   				}else{
   					nodeWidth += chineseWidth;
   				}
   			}
   		} else {
   			if(/\n/g.test(textArr[i])){
   				rowText.push({
   					type: &amp;quot;break&amp;quot;,
   					content: text.substring(previousNode, i)
   				});
   				previousNode = i + 1;
   				nodeWidth = 0;
   				letterWidth = 0;
   			}else if(textArr[i] == &amp;quot;\\&amp;quot; &amp;amp;&amp;amp; textArr[i + 1] == &amp;quot;n&amp;quot;){
   				rowText.push({
   					type: &amp;quot;break&amp;quot;,
   					content: text.substring(previousNode, i)
   				});
   				previousNode = i + 2;
   				nodeWidth = 0;
   				letterWidth = 0;
   			}else if(/[a-zA-Z0-9]/g.test(textArr[i])){
   				letterWidth += 1;
   				if(nodeWidth + letterWidth * otherWidth &amp;gt; maxWidth){
   					rowText.push({
   						type: &amp;quot;text&amp;quot;,
   						content: text.substring(previousNode, i + 1 - letterWidth)
   					});
   					previousNode = i + 1 - letterWidth;
   					nodeWidth = letterWidth * otherWidth;
   					letterWidth = 0;
   				}
   			} else{
   				if(nodeWidth + otherWidth &amp;gt; maxWidth){
   					rowText.push({
   						type: &amp;quot;text&amp;quot;,
   						content: text.substring(previousNode, i)
   					});
   					previousNode = i;
   					nodeWidth = otherWidth;
   				}else{
   					nodeWidth += otherWidth;
   				}
   			}
   		}
   	}
   	if (previousNode &amp;lt; len) {
   		rowText.push({
   			type: &amp;quot;text&amp;quot;,
   			content: text.substring(previousNode, len)
   		});
   	}
   	return rowText;
   }
   
   export default {
   	data() {
   	    return {
   			hbimg:&amp;quot;&amp;quot;，
   	    }
   	}，
       onLoad(e) {
   		let hb = this.createPoster();
           hb.then(function(data){
               this.hbimg = data;
           });
   	},
   	methods:{
   		 // 创建海报
   		 createPoster() {
   		 	 return new Promise((resolve, reject) =&amp;gt; {
   		 		let qrcode = qr.createQrCodeImg(二维码地址);
   		 		const ctx = uni.createCanvasContext(&#39;poster&#39;);
   		 		let	that = this;
   		 		ctx.fillRect(0, 0, 375, 673);
   		 		ctx.setFillStyle(&amp;quot;#FFF&amp;quot;);
   		 		ctx.fillRect(0, 0, 375, 673);
   		 		// 淘宝logo
   		 		ctx.drawImage(淘宝logo本地地址, 30, 40, 25, 20);
   		 		// 商品标题
   		 		ctx.setFontSize(18);
   		 		ctx.setFillStyle(&#39;#333&#39;);
   		 		let textTop = 40;
   		 		let drawtextList = drawtext(商品标题, 330);
   		 		drawtextList.forEach((item,index) =&amp;gt; {
   		 			if(index==1 &amp;amp;&amp;amp; index &amp;lt; 2){
   		 				textTop = textTop + (index + 1) * 10;
   		 				let str = item.content.substring(0,item.content.length-1+ &#39;...&#39;;
   		 				ctx.fillText(str, 63, textTop);
   		 			}else if(index==0 &amp;amp;&amp;amp; index &amp;lt; 2){
   		 				textTop = textTop + (index + 1) * 10;
   		 				ctx.fillText(item.content, 63, textTop);
   		 			}
   		 		});
   		 		// 商品价格
   		 		ctx.setFontSize(14);
   		 		ctx.setFillStyle(&#39;#f00&#39;);
   		 		ctx.fillText(&amp;quot;券后价 ¥&amp;quot;+商品价格, 30, textTop + 30);
   		 		// 商品门市价
   		 		ctx.setFontSize(12);
   		 		ctx.setFillStyle(&#39;#999&#39;);
   		 		let textLeft = 30;
   		 		ctx.fillText(&amp;quot;原价 ¥&amp;quot;+商品原价, 30, textTop + 60);
   		 		// 商品门市价横线
   		 		ctx.beginPath();
   		 		ctx.setLineWidth(1);
   		 		ctx.moveTo(textLeft + 25, textTop + 55);
   		 		ctx.lineTo(textLeft + 8 + 商品原价.toString().length * 13, textTop + 55);
   		 		ctx.setStrokeStyle(&#39;#999&#39;);
   		 		ctx.stroke();
   		 		// 商品销售量
   		 		ctx.setFontSize(12);
   		 		ctx.setFillStyle(&#39;#999&#39;);
   		 		ctx.fillText(&amp;quot;销量 &amp;quot;+商品销售量, 120, textTop + 60);
   		 		//优惠券图
   		 		let len = that.goods.coupon_amount.toString().length
   		 		ctx.drawImage(优惠券底部背景图地址 270, textTop+48, 40+len*5, 20 );
   		 		// 商品优惠券金额
   		 		ctx.setFontSize(12);
   		 		ctx.setFillStyle(&#39;#FFF&#39;);
   		 		ctx.fillText(&amp;quot;¥&amp;quot;+优惠券金额, 280, textTop + 63);
   		 		//商品图
   		 		ctx.drawImage(商品图片地址, 30, textTop+80, 310, 310 );
   		 		// 平台logo
   		 		ctx.drawImage(平台logo图地址, 30, textTop + 425, 60, 60);
   		 		// 平台名称
   		 		ctx.setFontSize(16);
   		 		ctx.setFillStyle(&#39;#999&#39;);
   		 		ctx.fillText(平台名称, 103, textTop + 460);
   		 		// 长按识别二维码访问
   		 		ctx.setFontSize(16);
   		 		ctx.setFillStyle(&#39;#999&#39;);
   		 		ctx.fillText(&amp;quot;长按图片&amp;quot;, 30, textTop + 510);
   		 		// 长按识别二维码访问
   		 		ctx.setFontSize(16);
   		 		ctx.setFillStyle(&#39;#999&#39;);
   		 		ctx.fillText(&amp;quot;扫码领取优惠券&amp;quot;, 30, textTop + 530);
   		 		// 二维码
   		 		ctx.drawImage(上面生成的二维码, 220, textTop + 430, 120, 120);
   		 		ctx.stroke();
   		 		ctx.draw(true, function(){
   		 			// canvas画布转成图片并返回图片地址
   		 			uni.canvasToTempFilePath({
   		 				canvasId: &#39;poster&#39;,
   		 				fileType:&amp;quot;jpg&amp;quot;,
   		 				success: (res) =&amp;gt; {
   		 					resolve(res.tempFilePath);
   		 				},
   		 				fail: () =&amp;gt; {
   		 					reject();
   		 				}
   		 			})
   		 		})
   		      })
   		 }, 
   	
   	}
   }

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;结果&#34;&gt;结果&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1596610408680.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">uni-app canvas 绘制海报图</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/2RM9DBOkg/"" data-c="
          &lt;h3 id=&#34;时间类型&#34;&gt;时间类型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;time.Time&lt;/code&gt;类型表示时间，通过&lt;code&gt;time.Now()&lt;/code&gt;函数获取当前时间对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func getTime(){
    now := time.Now() //获取当前时间对象
    fmt.Println(now) // 2020-07-15 09:16:15.85101 +0800 CST m=+0.000154330

	year := now.Year() // 年
	fmt.Println(year) // 2020
	month := now.Month() // 月
	fmt.Println(month) // July
	day := now.Day() // 日
	fmt.Println(day) // 15
	hour := now.Hour() // 时
	fmt.Println(hour) // 9
	minute := now.Minute() // 分
	fmt.Println(minute) // 16
	second := now.Second() // 秒
	fmt.Println(second) //15
	fmt.Printf(&amp;quot;%d-%02d-%02d %02d:%02d:%02d\n&amp;quot;, year, month, day, hour, minute, second) // 2020-07-15 09:16:15 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;时间戳&#34;&gt;时间戳&lt;/h3&gt;
&lt;p&gt;根据当前时间对象获取时间戳&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func getTimeUnix(){
    now := time.Now() //获取当前时间对象
    time1 := now.Unix() //时间戳
    time2 := now.UnixNano() //纳秒时间戳
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把时间戳转化为时间格式，使用&lt;code&gt;time.Unix()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func timeFormat(){
    timeObj := time.Unix(timestamp, 0) //将时间戳转为时间格式
	fmt.Println(timeObj)
	year := timeObj.Year()     //年
	month := timeObj.Month()   //月
	day := timeObj.Day()       //日
	hour := timeObj.Hour()     //小时
	minute := timeObj.Minute() //分钟
	second := timeObj.Second() //秒
	fmt.Printf(&amp;quot;%d-%02d-%02d %02d:%02d:%02d\n&amp;quot;, year, month, day, hour, minute, second)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;时间间隔&#34;&gt;时间间隔&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;time.Duration&lt;/code&gt;是&lt;code&gt;time&lt;/code&gt;包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。&lt;code&gt;time.Duration&lt;/code&gt;表示一段时间间隔，可表示的最长时间段大约290年。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;time&lt;/code&gt;包中定义的时间间隔类型的常量如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-const&#34;&gt;    Nanosecond  Duration = 1
    Microsecond          = 1000 * Nanosecond
    Millisecond          = 1000 * Microsecond
    Second               = 1000 * Millisecond
    Minute               = 60 * Second
    Hour                 = 60 * Minute
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如：&lt;code&gt;time.Duration&lt;/code&gt;表示1纳秒，&lt;code&gt;time.Second&lt;/code&gt;表示1秒。&lt;/p&gt;
&lt;h3 id=&#34;时间操作&#34;&gt;时间操作&lt;/h3&gt;
&lt;p&gt;Add&lt;br&gt;
&lt;code&gt;func (t Time) Add(d Duration) Time&lt;/code&gt;&lt;br&gt;
例子，求一个小时之后的时间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func main(){
    now := time.Now()
    nowTime := now.Add(time.Hour) //当前时间加1小时后的时间
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sub 求两个时间之间的差值&lt;br&gt;
&lt;code&gt;func (t Time) Sub(u Time) Duration&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Equal 判断两个时间是否相同，会考虑时区影响&lt;br&gt;
&lt;code&gt;func (t Time) Equal(u Time) bool&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Before 判断一段时间是否在另一段时间之前 返回bool&lt;br&gt;
&lt;code&gt;func (t time) Before(u time) bool&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;After 判断一段时间是否在另一段时间之后 返回bool&lt;br&gt;
&lt;code&gt;func (t time) After(u Time) bool&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;定时器&#34;&gt;定时器&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;time.Tick(时间间隔)&lt;/code&gt;设置定时器。定时器的本质是一个通道(channel)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func tickDemo() {
	ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器
	for i := range ticker {
		fmt.Println(i)//每秒都会执行的任务
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;时间格式化&#34;&gt;时间格式化&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Format&lt;/code&gt;是对时间类型格式化的方法&lt;br&gt;
Go语言中格式时间模版不是&lt;code&gt;Y-m-d H:M:S&lt;/code&gt;,而是使用GO的诞生时间2006年1月2号15点04分05秒(2006 1 2 3 4 5).如果项格式为12小时方式，需指定&lt;code&gt;PM&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func formatDemo() {
	now := time.Now()
	// 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan
	// 24小时制
	fmt.Println(now.Format(&amp;quot;2006-01-02 15:04:05.000 Mon Jan&amp;quot;))
	// 12小时制
	fmt.Println(now.Format(&amp;quot;2006-01-02 03:04:05.000 PM Mon Jan&amp;quot;))
	fmt.Println(now.Format(&amp;quot;2006/01/02 15:04&amp;quot;))
	fmt.Println(now.Format(&amp;quot;15:04 2006/01/02&amp;quot;))
	fmt.Println(now.Format(&amp;quot;2006/01/02&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解析字符串格式的时间&#34;&gt;解析字符串格式的时间&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;now := time.Now()
fmt.Println(now)
// 加载时区
loc, err := time.LoadLocation(&amp;quot;Asia/Shanghai&amp;quot;)
if err != nil {
	fmt.Println(err)
	return
}
// 按照指定时区和指定格式解析字符串时间
timeObj, err := time.ParseInLocation(&amp;quot;2006/01/02 15:04:05&amp;quot;, &amp;quot;2019/08/04 14:15:20&amp;quot;, loc)
if err != nil {
	fmt.Println(err)
	return
}
fmt.Println(timeObj)
fmt.Println(timeObj.Sub(now))
&lt;/code&gt;&lt;/pre&gt;
">GO time包</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/iYDeoWK2N/"" data-c="
          &lt;p&gt;对于复合索引：Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index （a,b,c）。 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;以下是一些例子：&lt;/p&gt;
&lt;p&gt;(1) select * from myTest where a=3 and b=5 and c=4; ---- abc顺序&lt;br&gt;
abc三个索引都在where条件里面用到了，而且都发挥了作用&lt;/p&gt;
&lt;p&gt;(2) select * from myTest where c=4 and b=6 and a=3;&lt;br&gt;
where里面的条件顺序在查询之前会被mysql自动优化，效果跟上一句一样&lt;/p&gt;
&lt;p&gt;(3) select * from myTest where a=3 and c=7;&lt;br&gt;
a用到索引，b没有用，所以c是没有用到索引效果的（b没有使用到，所以索引达不到 c ，所以c未使用索引）&lt;/p&gt;
&lt;p&gt;(4) select * from myTest where a=3 and b&amp;gt;7 and c=3; ---- b范围值，断点，阻塞了c的索引&lt;br&gt;
a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引&lt;/p&gt;
&lt;p&gt;(5) select * from myTest where b=3 and c=4; — 联合索引必须按照顺序使用，并且需要全部使用&lt;br&gt;
因为a索引没有使用，所以这里 bc都没有用上索引效果&lt;/p&gt;
&lt;p&gt;(6) select * from myTest where a&amp;gt;4 and b=7 and c=9;&lt;br&gt;
a用到了 b没有使用，c没有使用（a用了范围所以，相当于断点，之后的b，c都没有用到索引）&lt;/p&gt;
&lt;p&gt;(7) select * from myTest where a=3 order by b;&lt;br&gt;
a用到了索引，b在结果排序中也用到了索引的效果，a下面任意一段的b是排好序的&lt;/p&gt;
&lt;p&gt;(8) select * from myTest where a=3 order by c;&lt;br&gt;
a用到了索引，但是这个地方c没有发挥排序效果，因为中间断点了，使用 explain 可以看到 filesort&lt;/p&gt;
&lt;p&gt;(9) select * from mytable where b=3 order by a;&lt;br&gt;
b没有用到索引，排序中a也没有发挥索引效果&lt;/p&gt;
&lt;p&gt;以下条件会导致索引失效：&lt;br&gt;
1.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描&lt;br&gt;
2.存储引擎不能使用索引范围条件右边的列（例如 只用到b ， c）&lt;br&gt;
3.尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select ***&lt;br&gt;
4.mysql在使用不等于（！=或者&amp;lt;&amp;gt;）的时候**无法使用索引会导致全表扫描&lt;/p&gt;
&lt;p&gt;5.is null,is not null也无法使用索引&lt;/p&gt;
&lt;p&gt;6.ike以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操作。问题：解决like‘%字符串%’时索引不被使用的方法&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1595301667226.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;7.字符串不加单引号索引失效&lt;/p&gt;
&lt;p&gt;建议：&lt;/p&gt;
&lt;p&gt;对于单键索引，尽量选择针对当前query过滤性更好的索引&lt;/p&gt;
&lt;p&gt;在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。&lt;/p&gt;
&lt;p&gt;. 在选择组合索引的时候，尽量选择可以能够包含当前query中的where子句中更多字段的索引&lt;/p&gt;
&lt;p&gt;. 在选择组合索引的时候，尽量选择可以能够包含当前query中的where子句中更多字段的索引&lt;/p&gt;
&lt;p&gt;尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的&lt;/p&gt;
&lt;p&gt;版权声明：本文为博主原创文章，遵循 CC 4.0 by-sa 版权协议，转载请附上原文出处链接和本声明。 本文链接：https://blog.csdn.net/qq_42630887/article/details/97113323&lt;/p&gt;
">ABC联合索引生效问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/Z_ENFNWmH/"" data-c="
          &lt;p&gt;今天在review代码查看SQL语句时突然对没有指定排序方式的SQL语句返回怎样的排序结构感兴趣！在某些场景中返回结果中的元素到底是按照什么顺序以什么字段排序的将直接影响到整个业务是否正确。例如myBatis中语句如下:&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;
&amp;lt;select id=&amp;quot;get_by_id&amp;quot; resultMap=&amp;quot;App&amp;quot;  parameterClass=&amp;quot;java.lang.Long&amp;quot;&amp;gt;  
select &amp;lt;include refid=&amp;quot;fileds&amp;quot;/&amp;gt; from table_a where id = #id# and type = 2 and state != 0  
&amp;lt;/select&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;排查问题&lt;/p&gt;
&lt;p&gt;那么到底MySQL在没有指定排序字段以及排序顺序时是按照什么规则排序呢？最早猜测是按照主键排序，即在table_a表中按照id字段进行降序排列。那么到底是否正确呢？为了验证猜测，在本地通过Navicat8对这个猜测进行了验证：SELECT * FROM test_a查询结果：&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1595296853216.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现查询结果并没有按照猜测的方式进行排序，并且查询结果没有任何规律可循。这样看来如果按照上述的方式处理业务是很有可能出现问题的。仔细想了一下，这个问题应该和数据库存储引擎有关系，然后再网上查阅了一下这个问题，发现各种说法都有，但是初步验证了这个问题确实和数据库存储引擎有关系，不同的数据库引擎对默认排序的处理是不一致的，但是都没有统一的答案，因此决定测试一下常用的两种数据库引擎：InnoDB以及MyISAM，简单介绍一下两个数据库引擎：&lt;/p&gt;
&lt;p&gt;简单点说就是InnoDB的优点是支持事务，支持非锁定读，行锁设计，以及全文索引，MyISAM的优点是操作速度快，不支持事务以及行锁，是MySQL默认的存储引擎。&lt;/p&gt;
&lt;p&gt;在本地创建两个表a，b，两个表唯一的区别在于a使用MyISAM作为存储引擎，b使用InnoDB作为存储引擎，然后两个表均忘表中插入100条数据。在插入数据后对量表分别进行无排序的全表查询结果如下：&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1595300430439.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;(表a：MyISAM）&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1595296897370.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;（表b：InnoDB）&lt;br&gt;
从查询结果上来看两个表是否都按照id进行升序排列，与table_a表查询结果顺序完全不一致，查看一下开发环境的table_a表的存储引擎为MyISAM，与表a一致，但是查询结果却没有任何相似的地方，是什么影响了table_a表的查询结果呢？难道是各种增删改查操作？因为两个相同引擎的表都进行无排序的全表查询唯一区别是表a没有进行过任何的更新删除操作，表table_a进行过大量的增删改查操作，于是对表a以及表b均模拟进行大量的增删改查操作，然后再次进行查询：&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1595300470557.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt; (表a：MyISAM）&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1595296915571.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;（表b：InnoDB）&lt;/p&gt;
&lt;p&gt;发现表a查询结果出现了无序情况，表象与表table_a一致，而表b查询结果仍然按照id进行升序排列。&lt;/p&gt;
&lt;p&gt;因此初步判定在MySQL中，如果使用MyISAM作为存储引擎，那么在进行默认排序的查询时，如果表没有进行过任何的更新删除等操作，那么查询结果将按照出入顺序进行升序排列，但是如果对表进行了更新删除等操作后，查询结果将是无序的；如果使用InnoDB作为存储引擎，那么在存在主键的情况下，查询结果将按照主键进行排序。因此在编写默认排序的SQL语句的时候，一定要注意使用的存储引擎，不同的存储引擎可能产生的查询结果完全不一致。&lt;/p&gt;
&lt;p&gt;猜想原因：应该和两种存储引擎采用的存储结构有关系，在查阅资料以后发现InnoDB采用的是聚簇索引表，而MyISAM采用的是无序的堆表结构。最后在MySQL的官方网页上发现了对该问题的一个描述：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;SELECT * FROM tbl -- this will do a &amp;quot;table scan&amp;quot;. If the table has never had any DELETEs/REPLACEs/UPDATEs, the records will happen to be in the insertion order, hence what you observed. 
If you had done the same statement with an InnoDB table, they would have been delivered in PRIMARY KEY order, not INSERT order. Again, this is an artifact of the underlying implementation, not something to depend on.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大概意思是说在使用默认的存储引擎（MyISAM）进行全表查询时，会进行表扫描，如果表没有进行过删除、替换以及更新操作，那么查询结果将按照插入顺序进行排序，如果在使用InnoDB作为存储引擎执行相同的操作时，查询结果将按照主键进行排序，而不是按照插入顺序进行排序的。&lt;br&gt;
————————————————&lt;br&gt;
版权声明：本文为CSDN博主「南山一梦三四年」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。&lt;br&gt;
原文链接：https://blog.csdn.net/leining_chris/article/details/39497703&lt;/p&gt;
">MyISAM以及InnoDB引擎默认排序方式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/jvx7Ng7mp/"" data-c="
          &lt;p&gt;首先介绍这些索引的概念：&lt;br&gt;
1、聚集索引&lt;/p&gt;
&lt;p&gt;聚集索引：指索引项的排序方式和表中数据记录排序方式一致的索引&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;也就是说聚集索引的顺序就是数据的物理存储顺序。它会根据聚集索引键的顺序来存储表中的数据，即对表的数据按索引键的顺序进行排序，然后重新存储到磁盘上。因为数据在物理存放时只能有一种排列方式，所以一个表只能有一个聚集索引。&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594898785007.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;比如字典中，用‘拼音’查汉字，就是聚集索引。因为正文中字都是按照拼音排序的。而用‘偏旁部首’查汉字，就是非聚集索引，因为正文中的字并不是按照偏旁部首排序的，我们通过检字表得到正文中的字在索引中的映射，然后通过映射找到所需要的字。&lt;/p&gt;
&lt;p&gt;聚集索引的使用场合为：&lt;/p&gt;
&lt;p&gt;a.查询命令的回传结果是以该字段为排序依据的；&lt;/p&gt;
&lt;p&gt;b.查询的结果返回一个区间的值；&lt;/p&gt;
&lt;p&gt;c.查询的结果返回某值相同的大量结果集。&lt;/p&gt;
&lt;p&gt;聚集索引会降低 insert，和update操作的性能，所以，是否使用聚集索引要全面衡量。&lt;/p&gt;
&lt;p&gt;2、非聚集索引： 索引顺序与物理存储顺序不同&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594898800060.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;非聚集索引的使用场合为：&lt;/p&gt;
&lt;p&gt;a.查询所获数据量较少时；&lt;/p&gt;
&lt;p&gt;b.某字段中的数据的唯一性比较高时；&lt;/p&gt;
&lt;p&gt;非聚集索引必须是稠密索引&lt;/p&gt;
&lt;p&gt;3、聚簇索引&lt;/p&gt;
&lt;p&gt;聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。术语“聚族”表示数据行和相邻的键值紧凑的存储在一起。因为无法同时把数据行放在两个不同的地方，所以一个表只能有一个聚族索引。&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594898814943.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;聚族索引的优点&lt;/p&gt;
&lt;p&gt;可以把相关数据保存在一起。就好像在操场上战队，一个院系一个院系的站在一起，这样要找到一个人，就先找到他的院系，然后在他的院系里找到他就行了，而不是把学校里的所有人都遍历一遍&lt;/p&gt;
&lt;p&gt;数据访问更快。聚族索引将索引和数据保存在同一个B-Tree中，因此从聚族索引中获取数据通常比在非聚族索引中查找更快&lt;/p&gt;
&lt;p&gt;4、稠密索引&lt;/p&gt;
&lt;p&gt;稠密索引：每个索引键值都对应有一个索引项&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594898824043.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;稠密索引能够比稀疏索引更快的定位一条记录。但是，稀疏索引相比于稠密索引的优点是：它所占空间更小，且插入和删除时的维护开销也小。&lt;/p&gt;
&lt;p&gt;5、稀疏索引&lt;/p&gt;
&lt;p&gt;稀疏索引：相对于稠密索引，稀疏索引只为某些搜索码值建立索引记录；在搜索时，找到其最大的搜索码值小于或等于所查找记录的搜索码值的索引项，然后从该记录开始向后顺序查询直到找到为止。&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594898834027.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;接着结合mysql进行讲解：&lt;br&gt;
mysql的两种数据存储方式，一种是InnoDB，一种是MyISAM。这两种存储都是基于B+树的存储方式，但是也有点不同。&lt;/p&gt;
&lt;p&gt;MyIsam 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。主索引和辅助索引没有区别都是非聚集索引。索引页正常大小为1024字节，索引页存放在.MYI 文件中。MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。&lt;/p&gt;
&lt;p&gt;InnoDB 也使用B+Tree作为索引结构，索引页大小16，和表数据页共同存放在表空间中。从InnoDB表数据存放方式可看出InnoDB表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。&lt;/p&gt;
&lt;p&gt;InnoDB默认对主键建立聚簇索引。如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。一般来说，InnoDB 会以聚簇索引的形式来存储实际的数据，它是其它二级索引的基础。&lt;/p&gt;
&lt;p&gt;所以mysql innodb引擎的聚集索引、聚簇索引都默认是主键索引，如果没有指定主键，就是一个具有唯一且非空值的索引，如果不存在这样的索引，就是InnoDB自定义的隐藏主键索引，并且该索引是稠密索引。&lt;/p&gt;
">mysql中的聚集索引、非聚集索引、聚簇索引、稀疏索引、稠密索引</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/6ZVP7IE6V/"" data-c="
          &lt;p&gt;公司近期要做淘客项目，需要给每个会员生成一串唯一性的邀请码，在网上在了很多资料，最后找到一个自认为不错的设计，再次分享一下&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function create_invite_code(){

​        $code = &#39;&#39;; //保存生成的code码

​        $char = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;; //26个字符

​        $char2 = &#39;ABCDEFGHJKLMNPQRSTUVWXYZ&#39;; //24个字符

​        $data[0] = $char[mt_rand(0,25)]; //值为A~Z

​        $data[1] = strtoupper(dechex(Date(&#39;m&#39;,time()))); //值为1~C

​        $data[2] = Date(&#39;d&#39;,time()); //值为1~31

​        $data[3] = substr(time(),-5); //时间戳后5位

​        $data[4] = substr(microtime(),2,5); //值为微秒的小数点后5位

​        $data[5] = sprintf(&#39;%02d&#39;,rand(0,99)); //值为0~99

​        $str = implode(&#39;&#39;, $data); //合并为字符串

​        $bin = md5($str, true ); //16字节的二进制数据

​        for($i=0;$i&amp;lt;6;$i++){

​            $a8 = ord($bin[$i]); //$a8保存前6字节的循环数据 ASCII 值

​            $b8 = ord($bin[$i+6]); //$b8保存后6字节的循环数据 ASCII 值

​            $index = ($a8 ^ $b8) - $a8 &amp;amp; 0x17; //0x17表示23，即$index的范围为0~23

​            $code .= $char2[$index]; //根据下标取出$char2中字符串

​        }

​        return  $code;

​    }

​    echo create_invite_code();
&lt;/code&gt;&lt;/pre&gt;
">邀请码的设计</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/E4ZClyFIL/"" data-c="
          &lt;p&gt;web-view 是一个 web 浏览器组件，可以用来承载网页的容器，会自动铺满整个页面。&lt;/p&gt;
&lt;p&gt;但是web-view铺满全屏  1.状态栏遮挡页面  2.没有区别app和h5页面&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;所以  打算加一个顶部导航&lt;/p&gt;
&lt;p&gt;放入web-view组件&lt;/p&gt;
&lt;p&gt;这就遇到了web-view铺满的问题  如果直接在页面中直接写入web-view组件放入url  那就铺满了&lt;/p&gt;
&lt;p&gt;想放个标题或者是不想让状态栏遮挡的话怎么办呢？&lt;/p&gt;
&lt;p&gt;一种：引用了web-view组件之后  进行修改&lt;/p&gt;
&lt;p&gt;// #ifdef APP-PLUS&lt;/p&gt;
&lt;p&gt;var currentWebview = this.&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;mp.page.&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;getAppWebview() //获取当前页面的webview对象&lt;/p&gt;
&lt;p&gt;setTimeout(function() {&lt;/p&gt;
&lt;p&gt;wv   = currentWebview.children()[0]&lt;/p&gt;
&lt;p&gt;wv.setStyle({top:150,height:300})&lt;/p&gt;
&lt;p&gt;}, 1000); //如果是页面初始化调用时，需要延时一下&lt;/p&gt;
&lt;p&gt;// #endif&lt;/p&gt;
&lt;p&gt;一种：直接用js创建web-view组件&lt;/p&gt;
&lt;p&gt;// #ifdef APP-PLUS&lt;/p&gt;
&lt;p&gt;var w=plus.webview.create(url,&#39;id&#39;,{&lt;/p&gt;
&lt;p&gt;top:uni.getSystemInfoSync().statusBarHeight+50，&lt;/p&gt;
&lt;p&gt;//放置在titleNView下方。如果还想在webview上方加个地址栏的什么的，可以继续降低TOP值&lt;/p&gt;
&lt;p&gt;//因为设置top之后 webview的高度依然不变会往下移 底部会被遮住  所以设置一下高度&lt;/p&gt;
&lt;p&gt;height:uni.getSystemInfoSync().windowHeight - 44 -uni.getSystemInfoSync().statusBarHeight&lt;/p&gt;
&lt;p&gt;},{preload:&#39;preload webview&#39;}); // 可直接通过以下方法获取preload值&lt;/p&gt;
&lt;p&gt;var currentWebview = this.&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;mp.page.&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;getAppWebview() //获取当前页面的webview对象&lt;/p&gt;
&lt;p&gt;currentWebview.append(w);//一定要append到当前的页面里！！！才能跟随当前页面一起做动画，一起关闭&lt;/p&gt;
&lt;p&gt;// #endif&lt;/p&gt;
&lt;p&gt;转载链接：https://www.jianshu.com/p/bc0504905d8e&lt;/p&gt;
">uni-app webview组件，页面铺面全屏问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/4AtekLall/"" data-c="
          &lt;p&gt;一、缓存处理流程&lt;/p&gt;
&lt;p&gt;前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返&lt;br&gt;
回结果，数据库也没取到，那直接返回空结果。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594806915998.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
二、缓存穿透&lt;/p&gt;
&lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;接口层增加校验，如用户鉴权校验，id做基础校验，id&amp;lt;=0的直接拦截；&lt;br&gt;
从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击&lt;br&gt;
三、缓存击穿&lt;/p&gt;
&lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;设置热点数据永远不过期。&lt;br&gt;
加互斥锁，互斥锁参考代码如下：&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594806894795.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
说明：&lt;/p&gt;
&lt;p&gt;1）缓存中有数据，直接走上述代码13行后就返回结果了&lt;/p&gt;
&lt;p&gt;2）缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。&lt;/p&gt;
&lt;p&gt;3）当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程A从数据库取key1的数据并不妨碍线程B取key2的数据，上面代码明显做不到这点。&lt;/p&gt;
&lt;p&gt;四、缓存雪崩&lt;/p&gt;
&lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，        缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。&lt;br&gt;
如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。&lt;br&gt;
设置热点数据永远不过期。&lt;/p&gt;
&lt;p&gt;转载：https://www.cnblogs.com/sbj-dawn/p/11116673.html&lt;/p&gt;
">缓存穿透、缓存击穿、缓存雪崩区别和解决方案</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/nqk-kNdhD/"" data-c="
          &lt;p&gt;forEach：（可以三个参数，第一个是value，第二个是index，第三个是数组体）&lt;/p&gt;
&lt;p&gt;缺点：不能同时遍历多个集合，在遍历的时候无法修改和删除集合数据，&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;方法不能使用break，continue语句跳出循环，或者使用return从函数体返回，对于空数组不会执行回调函数&lt;/p&gt;
&lt;p&gt;优点：便利的时候更加简洁，效率和for循环相同，不用关心集合下标的问题，减少了出错的效率&lt;/p&gt;
&lt;p&gt;定义：用于调用数组的每个元素，并将元素传递给回调函数&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;p&gt;//我们先用它来遍历数组&lt;br&gt;
let arry=[9,8,7,6,5,4]&lt;br&gt;
array.forEach(function(value,index,arr){&lt;br&gt;
console.log(value)&lt;br&gt;
})&lt;br&gt;
//输出结果为9 8 7 6 5 4&lt;/p&gt;
&lt;p&gt;//首先有人疑问它能不能用来遍历对象（一开始我也不知道）？&lt;br&gt;
//我们用它来遍历对象试试可不可以&lt;br&gt;
let obj={a:1,b:2,c:3,d:4}&lt;br&gt;
obj.forEach(function(value,index,oObj){&lt;br&gt;
console.log(value)&lt;br&gt;
}&lt;br&gt;
//输出结果会是obj.forEach is not a function，&lt;br&gt;
//所以forEach不可以遍历对象，这也是它和for in的一个区别&lt;/p&gt;
&lt;p&gt;for in:（它大部分用于遍历对象）&lt;/p&gt;
&lt;p&gt;定义：用于循环遍历数组或对象属性，fot in循环里面的index是string类型的，&lt;/p&gt;
&lt;p&gt;代码每执行一次，就会对数组的元素或者对象的属性进行一次操作&lt;/p&gt;
&lt;p&gt;缺点：某些情况下，会出现随机顺序的遍历，因为里面的值是string类型，所以&lt;br&gt;
增加了转换过程，因此开销较大&lt;/p&gt;
&lt;p&gt;优点：可以遍历数组的键名，遍历对象简洁方便&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;p&gt;//首先遍历对象&lt;br&gt;
let person={name:&amp;quot;老王&amp;quot;,age:23,city:&amp;quot;大唐&amp;quot;}&lt;br&gt;
let text=&amp;quot;&amp;quot;&lt;br&gt;
for (let i in person){&lt;br&gt;
text+=person[i]&lt;br&gt;
}&lt;br&gt;
输出结果为：老王23大唐&lt;/p&gt;
&lt;p&gt;//其次在尝试一些数组&lt;br&gt;
let arry=[1,2,3,4,5]&lt;br&gt;
for (let i in arry){&lt;br&gt;
console.log(arry[i])&lt;br&gt;
}&lt;br&gt;
//能输出出来，证明也是可以的&lt;/p&gt;
&lt;p&gt;for of:（可遍历map，object,array,set string等）用来遍历数据，比如组中的值，&lt;/p&gt;
&lt;p&gt;map,set会在下篇文章详解，这节只查看遍历对象和数组&lt;/p&gt;
&lt;p&gt;优点：避免了for in的所有缺点，可以使用break,continue和return，不仅支持&lt;/p&gt;
&lt;p&gt;数组的遍历，还可以遍历类似数组的对象，支持字符串的遍历&lt;br&gt;
最简洁，最直接的遍历数组的语法&lt;br&gt;
支持map和Set对象遍历&lt;/p&gt;
&lt;p&gt;缺点：不适用于处理原有的原生对象（原生对象是一个子集，包含一些在运动过程中动态创建的对象）&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;p&gt;//遍历数组&lt;br&gt;
let arr=[&amp;quot;nick&amp;quot;,&amp;quot;freddy&amp;quot;,&amp;quot;mike&amp;quot;,&amp;quot;james&amp;quot;];&lt;br&gt;
for (let item of arr){&lt;br&gt;
console.log(item)&lt;br&gt;
}&lt;br&gt;
//暑促结果为nice freddy mike james&lt;/p&gt;
&lt;p&gt;//遍历对象&lt;br&gt;
let person={name:&amp;quot;老王&amp;quot;,age:23,city:&amp;quot;唐山&amp;quot;}&lt;br&gt;
for (let item of person){&lt;br&gt;
console.log(item)&lt;br&gt;
}&lt;br&gt;
//我们发现它是不可以的&lt;br&gt;
//但是它和forEach有个解决方法，结尾介绍&lt;/p&gt;
&lt;p&gt;for：&lt;/p&gt;
&lt;p&gt;优点：程序简洁，结构清晰，循环初始化，循环变量化，循环体和循环条件位置突出&lt;/p&gt;
&lt;p&gt;缺点：结构比while循环复杂，容易出编码错误&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;p&gt;//首先它和forEach,forof一样不可以遍历对象&lt;br&gt;
//解决办法：就是把对象先转化为数组类型- -&lt;br&gt;
//有一个对象：&lt;br&gt;
let obj={a:1,b:2,c:3}&lt;br&gt;
//用Object.keys属性转化&lt;br&gt;
let obj2=Object.keys(obj)&lt;br&gt;
//最后就可以用来遍历了&lt;br&gt;
for (let i=0;i&amp;lt;obj2.length;i++){&lt;br&gt;
console.log(obj2[i])&lt;br&gt;
}&lt;br&gt;
//输出结果就能出来了，forEach，for of同理&lt;/p&gt;
&lt;p&gt;转载于:https://www.cnblogs.com/larrywang/p/10325988.html&lt;/p&gt;
">JS中的forEach,for in,for of和for的遍历优缺点及区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/3TRVjZYqd/"" data-c="
          &lt;p&gt;使用值接受者实现接口与使用指针接受者实现接口的区别&lt;/p&gt;
&lt;p&gt;使用值接受者实现接口，结构体类型和结构体指针类型的变量都能存。&lt;br&gt;
指针接受者实现接口只能存结构体指针类型的变量&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;值接受者&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594806629009.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
指针接受者&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594806636606.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">GO语言的值接受者和指针接受者实现接口的区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/V4katkucI/"" data-c="
          &lt;p&gt;首先php是这样解释的  语句里面出现运算符，那就认为是运算操作， 会将非int类型的数据强制转换为int。所以 intval(&#39;9a&#39; ) 等于 9， 然后加上1 就等于10&lt;/p&gt;
">php echo 1+"9a" 为什么等于10</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/WmRSLawKl/"" data-c="
          &lt;p&gt;array_change_key_case()	把数组中所有键更改为小写或大写。&lt;br&gt;
array_chunk()	把一个数组分割为新的数组块。&lt;br&gt;
array_column()	返回输入数组中某个单一列的值。&lt;br&gt;
array_combine()	通过合并两个数组来创建一个新数组。&lt;br&gt;
array_count_values()	用于统计数组中所有值出现的次数。&lt;br&gt;
array_diff()	比较数组，返回差集（只比较键值）。&lt;br&gt;
array_diff_assoc()	比较数组，返回差集（比较键名和键值）。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;array_diff_key()	比较数组，返回差集（只比较键名）。&lt;br&gt;
array_diff_uassoc()	比较数组，返回差集（比较键名和键值，使用用户自定义的键名比较函数）。&lt;br&gt;
array_diff_ukey()	比较数组，返回差集（只比较键名，使用用户自定义的键名比较函数）。&lt;br&gt;
array_fill()	用给定的键值填充数组。&lt;br&gt;
array_fill_keys()	用指定键名的给定键值填充数组。&lt;br&gt;
array_filter()	用回调函数过滤数组中的元素。&lt;br&gt;
array_flip()	交换数组中的键和值。&lt;br&gt;
array_intersect()	比较数组，返回交集（只比较键值）。&lt;br&gt;
array_intersect_assoc()	比较数组，返回交集（比较键名和键值）。&lt;br&gt;
array_intersect_key()	比较数组，返回交集（只比较键名）。&lt;br&gt;
array_intersect_uassoc()	比较数组，返回交集（比较键名和键值，使用用户自定义的键名比较函数）。&lt;br&gt;
array_intersect_ukey()	比较数组，返回交集（只比较键名，使用用户自定义的键名比较函数）。&lt;br&gt;
array_key_exists()	检查指定的键名是否存在于数组中。&lt;br&gt;
array_keys()	返回数组中所有的键名。&lt;br&gt;
array_map()	把数组中的每个值发送到用户自定义函数，返回新的值。&lt;br&gt;
array_merge()	把一个或多个数组合并为一个数组。&lt;br&gt;
array_merge_recursive()	递归地合并一个或多个数组。&lt;br&gt;
array_multisort()	对多个数组或多维数组进行排序。&lt;br&gt;
array_pad()	用值将数组填补到指定长度。&lt;br&gt;
array_pop()	删除数组的最后一个元素（出栈）。&lt;br&gt;
array_product()	计算数组中所有值的乘积。&lt;br&gt;
array_push()	将一个或多个元素插入数组的末尾（入栈）。&lt;br&gt;
array_rand()	返回数组中一个或多个随机的键。&lt;br&gt;
array_reduce()	通过使用用户自定义函数，以字符串返回数组。&lt;br&gt;
array_replace()	使用后面数组的值替换第一个数组的值。&lt;br&gt;
array_replace_recursive()	递归地使用后面数组的值替换第一个数组的值。&lt;br&gt;
array_reverse()	以相反的顺序返回数组。&lt;br&gt;
array_search()	搜索数组中给定的值并返回键名。&lt;br&gt;
array_shift()	删除数组中首个元素，并返回被删除元素的值。&lt;br&gt;
array_slice()	返回数组中被选定的部分。&lt;br&gt;
array_splice()	删除并替换数组中指定的元素。&lt;br&gt;
array_sum()	返回数组中值的和。&lt;br&gt;
array_udiff()	比较数组，返回差集（只比较值，使用一个用户自定义的键名比较函数）。&lt;br&gt;
array_udiff_assoc()	比较数组，返回差集（比较键和值，使用内建函数比较键名，使用用户自定义函数比较键值）。&lt;br&gt;
array_udiff_uassoc()	比较数组，返回差集（比较键和值，使用两个用户自定义的键名比较函数）。&lt;br&gt;
array_uintersect()	比较数组，返回交集（只比较值，使用一个用户自定义的键名比较函数）。&lt;br&gt;
array_uintersect_assoc()	比较数组，返回交集（比较键和值，使用内建函数比较键名，使用用户自定义函数比较键值）。&lt;br&gt;
array_uintersect_uassoc()	比较数组，返回交集（比较键和值，使用两个用户自定义的键名比较函数）。&lt;br&gt;
array_unique()	删除数组中的重复值。&lt;br&gt;
array_unshift()	在数组开头插入一个或多个元素。&lt;br&gt;
array_values()	返回数组中所有的值。&lt;br&gt;
array_walk()	对数组中的每个成员应用用户函数。&lt;br&gt;
array_walk_recursive()	对数组中的每个成员递归地应用用户函数。&lt;br&gt;
arsort()	对关联数组按照键值进行降序排序。&lt;br&gt;
asort()	对关联数组按照键值进行升序排序。&lt;br&gt;
compact()	创建包含变量名和它们的值的数组。&lt;br&gt;
count()	返回数组中元素的数目。&lt;br&gt;
current()	返回数组中的当前元素。&lt;br&gt;
each()	返回数组中当前的键／值对。&lt;br&gt;
end()	将数组的内部指针指向最后一个元素。&lt;br&gt;
extract()	从数组中将变量导入到当前的符号表。&lt;br&gt;
in_array()	检查数组中是否存在指定的值。&lt;br&gt;
key()	从关联数组中取得键名。&lt;br&gt;
krsort()	对数组按照键名逆向排序。&lt;br&gt;
ksort()	对数组按照键名排序。&lt;br&gt;
list()	把数组中的值赋给一些变量。&lt;br&gt;
natcasesort()	用“自然排序”算法对数组进行不区分大小写字母的排序。&lt;br&gt;
natsort()	用“自然排序”算法对数组排序。&lt;br&gt;
next()	将数组中的内部指针向前移动一位。&lt;br&gt;
pos()	current() 的别名。&lt;br&gt;
prev()	将数组的内部指针倒回一位。&lt;br&gt;
range()	创建包含指定范围单元的数组。&lt;br&gt;
reset()	将数组的内部指针指向第一个元素。&lt;br&gt;
rsort()	对数组逆向排序。&lt;br&gt;
shuffle()	将数组打乱。&lt;br&gt;
sizeof()	count() 的别名。&lt;br&gt;
sort()	对数组排序。&lt;br&gt;
uasort()	使用用户自定义的比较函数对数组中的键值进行排序。&lt;br&gt;
uksort()	使用用户自定义的比较函数对数组中的键名进行排序。&lt;br&gt;
usort()	使用用户自定义的比较函数对数组进行排序。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;!-- more --&gt;
&lt;!-- more --&gt;
">php 数组函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/gao-dong-zhe-xie-redis-zhi-shi-dian-diao-da-mian-shi-guan/"" data-c="
          &lt;p&gt;“今天，我不自量力的面试了某大厂的 Java 开发岗位，迎面走来一位风尘仆仆的中年男子，手里拿着屏幕还亮着的 Mac。&lt;/p&gt;
&lt;p&gt;他冲着我礼貌的笑了笑，然后说了句“不好意思，让你久等了”，然后示意我坐下，说：“我们开始吧，看了你的简历，觉得你对 Redis 应该掌握的不错，我们今天就来讨论下 Redis……”。我想：“来就来，兵来将挡水来土掩”。&lt;/p&gt;
&lt;p&gt;Redis 是什么&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;面试官：你先来说下 Redis 是什么吧！&lt;/p&gt;
&lt;p&gt;我：（这不就是总结下 Redis 的定义和特点嘛）Redis 是 C 语言开发的一个开源的（遵从 BSD 协议）高性能键值对（key-value）的内存数据库，可以用作数据库、缓存、消息中间件等。&lt;/p&gt;
&lt;p&gt;它是一种 NoSQL（not-only sql，泛指非关系型数据库）的数据库。&lt;/p&gt;
&lt;p&gt;我顿了一下，接着说，Redis 作为一个内存数据库：&lt;/p&gt;
&lt;p&gt;性能优秀，数据在内存中，读写速度非常快，支持并发 10W QPS。单进程单线程，是线程安全的，采用 IO 多路复用机制。丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。支持数据持久化。可以将内存中数据保存在磁盘中，重启时加载。主从复制，哨兵，高可用。可以用作分布式锁。可以作为消息中间件使用，支持发布订阅。&lt;/p&gt;
&lt;p&gt;五种数据类型&lt;/p&gt;
&lt;p&gt;面试官：总结的不错，看来是早有准备啊。刚来听你提到 Redis 支持五种数据类型，那你能简单说下这五种数据类型吗？&lt;/p&gt;
&lt;p&gt;我：当然可以，但是在说之前，我觉得有必要先来了解下 Redis 内部内存管理是如何描述这 5 种数据类型的。&lt;/p&gt;
&lt;p&gt;说着，我拿着笔给面试官画了一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594804792601.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我：首先 Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。&lt;/p&gt;
&lt;p&gt;redisObject 最主要的信息如上图所示：type 表示一个 value 对象具体是何种数据类型，encoding 是不同数据类型在 Redis 内部的存储方式。&lt;/p&gt;
&lt;p&gt;比如：type=string 表示 value 存储的是一个普通字符串，那么 encoding 可以是 raw 或者 int。&lt;/p&gt;
&lt;p&gt;我顿了一下，接着说，下面我简单说下 5 种数据类型：&lt;/p&gt;
&lt;p&gt;①String 是 Redis 最基本的类型，可以理解成与 Memcached一模一样的类型，一个 Key 对应一个 Value。Value 不仅是 String，也可以是数字。&lt;/p&gt;
&lt;p&gt;String 类型是二进制安全的，意思是 Redis 的 String 类型可以包含任何数据，比如 jpg 图片或者序列化的对象。String 类型的值最大能存储 512M。&lt;/p&gt;
&lt;p&gt;②Hash是一个键值（key-value）的集合。Redis 的 Hash 是一个 String 的 Key 和 Value 的映射表，Hash 特别适合存储对象。常用命令：hget，hset，hgetall 等。&lt;/p&gt;
&lt;p&gt;③List 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边） 常用命令：lpush、rpush、lpop、rpop、lrange（获取列表片段）等。&lt;/p&gt;
&lt;p&gt;应用场景：List 应用场景非常多，也是 Redis 最重要的数据结构之一，比如 Twitter 的关注列表，粉丝列表都可以用 List 结构来实现。&lt;/p&gt;
&lt;p&gt;数据结构：List 就是链表，可以用来当消息队列用。Redis 提供了 List 的 Push 和 Pop 操作，还提供了操作某一段的 API，可以直接查询或者删除某一段的元素。&lt;/p&gt;
&lt;p&gt;实现方式：Redis List 的是实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销。&lt;/p&gt;
&lt;p&gt;④Set 是 String 类型的无序集合。集合是通过 hashtable 实现的。Set 中的元素是没有顺序的，而且是没有重复的。常用命令：sdd、spop、smembers、sunion 等。&lt;/p&gt;
&lt;p&gt;应用场景：Redis Set 对外提供的功能和 List 一样是一个列表，特殊之处在于 Set 是自动去重的，而且 Set 提供了判断某个成员是否在一个 Set 集合中。&lt;/p&gt;
&lt;p&gt;⑤Zset 和 Set 一样是 String 类型元素的集合，且不允许重复的元素。常用命令：zadd、zrange、zrem、zcard 等。&lt;/p&gt;
&lt;p&gt;使用场景：Sorted Set 可以通过用户额外提供一个优先级（score）的参数来为成员排序，并且是插入有序的，即自动排序。&lt;/p&gt;
&lt;p&gt;当你需要一个有序的并且不重复的集合列表，那么可以选择 Sorted Set 结构。&lt;/p&gt;
&lt;p&gt;和 Set 相比，Sorted Set关联了一个 Double 类型权重的参数 Score，使得集合中的元素能够按照 Score 进行有序排列，Redis 正是通过分数来为集合中的成员进行从小到大的排序。&lt;/p&gt;
&lt;p&gt;实现方式：Redis Sorted Set 的内部使用 HashMap 和跳跃表（skipList）来保证数据的存储和有序，HashMap 里放的是成员到 Score 的映射。&lt;/p&gt;
&lt;p&gt;而跳跃表里存放的是所有的成员，排序依据是 HashMap 里存的 Score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。&lt;/p&gt;
&lt;p&gt;数据类型应用场景总结：&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594804824217.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;面试官：想不到你平时也下了不少工夫，那 Redis 缓存你一定用过的吧？&lt;/p&gt;
&lt;p&gt;我：用过的。&lt;/p&gt;
&lt;p&gt;面试官：那你跟我说下你是怎么用的？&lt;/p&gt;
&lt;p&gt;我是结合 Spring Boot 使用的。一般有两种方式，一种是直接通过 RedisTemplate 来使用，另一种是使用 Spring Cache 集成 Redis（也就是注解的方式）。&lt;/p&gt;
&lt;p&gt;Redis 缓存&lt;/p&gt;
&lt;p&gt;直接通过 RedisTemplate 来使用，使用 Spring Cache 集成 Redis pom.xml 中加入以下依赖：&lt;/p&gt;
&lt;p&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;&lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.session&lt;/groupId&gt;&lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;&lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;/dependencies&gt;&lt;/p&gt;
&lt;p&gt;spring-boot-starter-data-redis：在 Spring Boot 2.x 以后底层不再使用 Jedis，而是换成了 Lettuce。&lt;/p&gt;
&lt;p&gt;commons-pool2：用作 Redis 连接池，如不引入启动会报错。&lt;/p&gt;
&lt;p&gt;spring-session-data-redis：Spring Session 引入，用作共享 Session。&lt;/p&gt;
&lt;p&gt;配置文件 application.yml 的配置：&lt;/p&gt;
&lt;p&gt;server: port: 8082 servlet: session: timeout: 30msspring:cache:type: redis redis: host: 127.0.0.1 port: 6379password:# redis默认情况下有16个分片，这里配置具体使用的分片，默认为0database: 0 lettuce: pool:# 连接池最大连接数(使用负数表示没有限制),默认8max-active: 100&lt;/p&gt;
&lt;p&gt;创建实体类 User.java：&lt;br&gt;
public class UserimplementsSerializable{&lt;br&gt;
private staticfinallong serialVersionUID = 662692455422902539L;&lt;br&gt;
private Integer id;&lt;br&gt;
private String name;&lt;br&gt;
private Integer age;&lt;br&gt;
public User(){ }&lt;br&gt;
public User(Integer id, String name, Integer age){&lt;br&gt;
this.id = id;this.name = name;&lt;br&gt;
this.age = age;&lt;br&gt;
}&lt;br&gt;
public Integer getId(){&lt;br&gt;
return id;&lt;br&gt;
}&lt;br&gt;
public voidsetId(Integer id){&lt;br&gt;
this.id = id;&lt;br&gt;
}&lt;br&gt;
public String getName(){&lt;br&gt;
return name;&lt;br&gt;
}&lt;br&gt;
public voidsetName(String name){&lt;br&gt;
this.name = name;&lt;br&gt;
}&lt;br&gt;
public Integer getAge(){&lt;br&gt;
return age;&lt;br&gt;
}&lt;br&gt;
public voidsetAge(Integer age){&lt;br&gt;
this.age = age;&lt;br&gt;
}&lt;br&gt;
@Override public String toString(){&lt;br&gt;
return&amp;quot;User{&amp;quot; +&amp;quot;id=&amp;quot; + id +&amp;quot;, name=&#39;&amp;quot; + name + &#39;&#39;&#39; +&amp;quot;, age=&amp;quot; + age +&#39;}&#39;; }&lt;br&gt;
}&lt;/p&gt;
&lt;p&gt;RedisTemplate 的使用方式&lt;/p&gt;
&lt;p&gt;默认情况下的模板只能支持 RedisTemplate&amp;lt;String, String&amp;gt;，也就是只能存入字符串，所以自定义模板很有必要。&lt;/p&gt;
&lt;p&gt;添加配置类 RedisCacheConfig.java：&lt;/p&gt;
&lt;p&gt;@Configuration@AutoConfigureAfter(RedisAutoConfiguration.class)publicclassRedisCacheConfig { @Beanpublic RedisTemplate&amp;lt;String, Serializable&amp;gt; redisCacheTemplate(LettuceConnectionFactory connectionFactory) { RedisTemplate&amp;lt;String, Serializable&amp;gt; template = new RedisTemplate&amp;lt;&amp;gt;();template.setKeySerializer(new StringRedisSerializer());template.setValueSerializer(new GenericJackson2JsonRedisSerializer());template.setConnectionFactory(connectionFactory);returntemplate; }}&lt;/p&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;p&gt;@RestController@RequestMapping(&amp;quot;/user&amp;quot;)publicclassUserController{public static Logger logger = LogManager.getLogger(UserController.class);@Autowiredprivate StringRedisTemplate stringRedisTemplate;@Autowiredprivate RedisTemplate&amp;lt;String, Serializable&amp;gt; redisCacheTemplate;@RequestMapping(&amp;quot;/test&amp;quot;)public void test() { redisCacheTemplate.opsForValue().set(&amp;quot;userkey&amp;quot;, new User(1, &amp;quot;张三&amp;quot;, 25)); User user = (User) redisCacheTemplate.opsForValue().get(&amp;quot;userkey&amp;quot;); logger.info(&amp;quot;当前获取对象：{}&amp;quot;, user.toString()); }&lt;/p&gt;
&lt;p&gt;然后在浏览器访问，观察后台日志 http://localhost:8082/user/test&lt;/p&gt;
&lt;p&gt;使用 Spring Cache 集成 Redis&lt;/p&gt;
&lt;p&gt;Spring Cache 具备很好的灵活性，不仅能够使用 SPEL（spring expression language）来定义缓存的 Key 和各种 Condition，还提供了开箱即用的缓存临时存储方案，也支持和主流的专业缓存如 EhCache、Redis、Guava 的集成。&lt;/p&gt;
&lt;p&gt;定义接口 UserService.java：&lt;/p&gt;
&lt;p&gt;publicinterfaceUserService {User save(User user);voiddelete(int id);User get(Integer id);}&lt;/p&gt;
&lt;p&gt;接口实现类 UserServiceImpl.java：&lt;/p&gt;
&lt;p&gt;@ServicepublicclassUserServiceImplimplementsUserService{publicstatic Logger logger = LogManager.getLogger(UserServiceImpl.class);privatestatic Map&amp;lt;Integer, User&amp;gt; userMap = new HashMap&amp;lt;&amp;gt;();static { userMap.put(1, new User(1, &amp;quot;肖战&amp;quot;, 25)); userMap.put(2, new User(2, &amp;quot;王一博&amp;quot;, 26)); userMap.put(3, new User(3, &amp;quot;杨紫&amp;quot;, 24)); }@CachePut(value =&amp;quot;user&amp;quot;, key = &amp;quot;#user.id&amp;quot;)@Overridepublic User save(User user){ userMap.put(user.getId(), user); logger.info(&amp;quot;进入save方法，当前存储对象：{}&amp;quot;, user.toString());return user; }@CacheEvict(value=&amp;quot;user&amp;quot;, key = &amp;quot;#id&amp;quot;)@Overridepublicvoiddelete(int id){ userMap.remove(id); logger.info(&amp;quot;进入delete方法，删除成功&amp;quot;); }@Cacheable(value = &amp;quot;user&amp;quot;, key = &amp;quot;#id&amp;quot;)@Overridepublic User get(Integer id){ logger.info(&amp;quot;进入get方法，当前获取对象：{}&amp;quot;, userMap.get(id)==null?null:userMap.get(id).toString());return userMap.get(id); }}&lt;/p&gt;
&lt;p&gt;为了方便演示数据库的操作，这里直接定义了一个 Map&amp;lt;Integer,User&amp;gt; userMap。&lt;/p&gt;
&lt;p&gt;这里的核心是三个注解：&lt;/p&gt;
&lt;p&gt;@Cachable@CachePut@CacheEvict&lt;/p&gt;
&lt;p&gt;测试类：UserController&lt;/p&gt;
&lt;p&gt;@RestController@RequestMapping(&amp;quot;/user&amp;quot;)publicclassUserController{publicstatic Logger logger = LogManager.getLogger(UserController.class);@Autowiredprivate StringRedisTemplate stringRedisTemplate;@Autowiredprivate RedisTemplate&amp;lt;String, Serializable&amp;gt; redisCacheTemplate;@Autowiredprivate UserService userService;@RequestMapping(&amp;quot;/test&amp;quot;)publicvoidtest(){ redisCacheTemplate.opsForValue().set(&amp;quot;userkey&amp;quot;, new User(1, &amp;quot;张三&amp;quot;, 25)); User user = (User) redisCacheTemplate.opsForValue().get(&amp;quot;userkey&amp;quot;); logger.info(&amp;quot;当前获取对象：{}&amp;quot;, user.toString()); }@RequestMapping(&amp;quot;/add&amp;quot;)publicvoidadd(){ User user = userService.save(new User(4, &amp;quot;李现&amp;quot;, 30)); logger.info(&amp;quot;添加的用户信息：{}&amp;quot;,user.toString()); }@RequestMapping(&amp;quot;/delete&amp;quot;)publicvoiddelete(){ userService.delete(4); }@RequestMapping(&amp;quot;/get/{id}&amp;quot;)publicvoidget(@PathVariable(&amp;quot;id&amp;quot;) String idStr) throws Exception{if (StringUtils.isBlank(idStr)) {thrownew Exception(&amp;quot;id为空&amp;quot;); } Integer id = Integer.parseInt(idStr); User user = userService.get(id); logger.info(&amp;quot;获取的用户信息：{}&amp;quot;,user.toString()); }}&lt;/p&gt;
&lt;p&gt;用缓存要注意，启动类要加上一个注解开启缓存：&lt;/p&gt;
&lt;p&gt;@SpringBootApplication(exclude=DataSourceAutoConfiguration.class)@EnableCachingpublicclassApplication{publicstaticvoidmain(String[] args){ SpringApplication.run(Application.class, args); }}&lt;/p&gt;
&lt;p&gt;①先调用添加接口：http://localhost:8082/user/add&lt;/p&gt;
&lt;p&gt;②再调用查询接口，查询 id=4 的用户信息：&lt;/p&gt;
&lt;p&gt;可以看出，这里已经从缓存中获取数据了，因为上一步 add 方法已经把 id=4 的用户数据放入了 Redis 缓存 3、调用删除方法，删除 id=4 的用户信息，同时清除缓存：&lt;/p&gt;
&lt;p&gt;④再次调用查询接口，查询 id=4 的用户信息：&lt;/p&gt;
&lt;p&gt;没有了缓存，所以进入了 get 方法，从 userMap 中获取。&lt;/p&gt;
&lt;p&gt;缓存注解&lt;/p&gt;
&lt;p&gt;①@Cacheable&lt;/p&gt;
&lt;p&gt;根据方法的请求参数对其结果进行缓存：&lt;/p&gt;
&lt;p&gt;Key：缓存的 Key，可以为空，如果指定要按照 SPEL 表达式编写，如果不指定，则按照方法的所有参数进行组合。Value：缓存的名称，必须指定至少一个（如 @Cacheable (value=&#39;user&#39;)或者 @Cacheable(value={&#39;user1&#39;,&#39;user2&#39;})）Condition：缓存的条件，可以为空，使用 SPEL 编写，返回 true 或者 false，只有为 true 才进行缓存。&lt;/p&gt;
&lt;p&gt;②@CachePut&lt;/p&gt;
&lt;p&gt;根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用。参数描述见上。&lt;/p&gt;
&lt;p&gt;③@CacheEvict&lt;/p&gt;
&lt;p&gt;根据条件对缓存进行清空：&lt;/p&gt;
&lt;p&gt;Key：同上。Value：同上。Condition：同上。allEntries：是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存。beforeInvocation：是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存。缺省情况下，如果方法执行抛出异常，则不会清空缓存。&lt;/p&gt;
&lt;p&gt;缓存问题&lt;/p&gt;
&lt;p&gt;面试官：看了一下你的 Demo，简单易懂。那你在实际项目中使用缓存有遇到什么问题或者会遇到什么问题你知道吗？&lt;/p&gt;
&lt;p&gt;我：缓存和数据库数据一致性问题：分布式环境下非常容易出现缓存和数据库间数据一致性问题，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。&lt;/p&gt;
&lt;p&gt;我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。&lt;/p&gt;
&lt;p&gt;合适的策略包括合适的缓存更新策略，更新数据库后及时更新缓存、缓存失败时增加重试机制。&lt;/p&gt;
&lt;p&gt;面试官：Redis 雪崩了解吗？&lt;/p&gt;
&lt;p&gt;我：我了解的，目前电商首页以及热点数据都会去做缓存，一般缓存都是定时任务去刷新，或者查不到之后去更新缓存的，定时任务刷新就有一个问题。&lt;/p&gt;
&lt;p&gt;举个栗子：如果首页所有 Key 的失效时间都是 12 小时，中午 12 点刷新的，我零点有个大促活动大量用户涌入，假设每秒 6000 个请求，本来缓存可以抗住每秒 5000 个请求，但是缓存中所有 Key 都失效了。&lt;/p&gt;
&lt;p&gt;此时 6000 个/秒的请求全部落在了数据库上，数据库必然扛不住，真实情况可能 DBA 都没反应过来直接挂了。&lt;/p&gt;
&lt;p&gt;此时，如果没什么特别的方案来处理，DBA 很着急，重启数据库，但是数据库立马又被新流量给打死了。这就是我理解的缓存雪崩。&lt;/p&gt;
&lt;p&gt;我心想：同一时间大面积失效，瞬间 Redis 跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的。&lt;/p&gt;
&lt;p&gt;你想想如果挂的是一个用户服务的库，那其他依赖他的库所有接口几乎都会报错。&lt;/p&gt;
&lt;p&gt;如果没做熔断等策略基本上就是瞬间挂一片的节奏，你怎么重启用户都会把你打挂，等你重启好的时候，用户早睡觉去了，临睡之前，骂骂咧咧“什么垃圾产品”。&lt;/p&gt;
&lt;p&gt;面试官摸摸了自己的头发：嗯，还不错，那这种情况你都是怎么应对的？&lt;/p&gt;
&lt;p&gt;我：处理缓存雪崩简单，在批量往 Redis 存数据的时候，把每个 Key 的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。&lt;/p&gt;
&lt;p&gt;setRedis（key, value, time+Math.random()*10000）;&lt;/p&gt;
&lt;p&gt;如果 Redis 是集群部署，将热点数据均匀分布在不同的 Redis 库中也能避免全部失效。&lt;/p&gt;
&lt;p&gt;或者设置热点数据永不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就好了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。&lt;/p&gt;
&lt;p&gt;面试官：那你了解缓存穿透和击穿么，可以说说他们跟雪崩的区别吗？&lt;/p&gt;
&lt;p&gt;我：嗯，了解，先说下缓存穿透吧，缓存穿透是指缓存和数据库中都没有的数据，而用户（黑客）不断发起请求。&lt;/p&gt;
&lt;p&gt;举个栗子：我们数据库的 id 都是从 1 自增的，如果发起 id=-1 的数据或者 id 特别大不存在的数据，这样的不断攻击导致数据库压力很大，严重会击垮数据库。&lt;/p&gt;
&lt;p&gt;我又接着说：至于缓存击穿嘛，这个跟缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了 DB。&lt;/p&gt;
&lt;p&gt;而缓存击穿不同的是缓存击穿是指一个 Key 非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个 Key 在失效的瞬间，持续的大并发直接落到了数据库上，就在这个 Key 的点上击穿了缓存。&lt;/p&gt;
&lt;p&gt;面试官露出欣慰的眼光：那他们分别怎么解决？&lt;/p&gt;
&lt;p&gt;我：缓存穿透我会在接口层增加校验，比如用户鉴权，参数做校验，不合法的校验直接 return，比如 id 做基础校验，id&amp;lt;=0 直接拦截。&lt;/p&gt;
&lt;p&gt;面试官：那你还有别的方法吗？&lt;/p&gt;
&lt;p&gt;我：我记得 Redis 里还有一个高级用法布隆过滤器（Bloom Filter）这个也能很好的预防缓存穿透的发生。&lt;/p&gt;
&lt;p&gt;它的原理也很简单，就是利用高效的数据结构和算法快速判断出你这个 Key 是否在数据库中存在，不存在你 return 就好了，存在你就去查 DB 刷新 KV 再 return。&lt;/p&gt;
&lt;p&gt;缓存击穿的话，设置热点数据永不过期，或者加上互斥锁就搞定了。作为暖男，代码给你准备好了，拿走不谢。&lt;/p&gt;
&lt;p&gt;publicstatic String getData(String key)throws InterruptedException {//从Redis查询数据 String result = getDataByKV(key);//参数校验if (StringUtils.isBlank(result)) {try {//获得锁if (reenLock.tryLock()) {//去数据库查询 result = getDataByDB(key);//校验if (StringUtils.isNotBlank(result)) {//插进缓存 setDataToKV(key, result); } } else {//睡一会再拿 Thread.sleep(100L); result = getData(key); } } finally {//释放锁 reenLock.unlock(); } }return result; }&lt;/p&gt;
&lt;p&gt;面试官：嗯嗯，还不错。&lt;/p&gt;
&lt;p&gt;Redis 为何这么快&lt;/p&gt;
&lt;p&gt;面试官：Redis 作为缓存大家都在用，那 Redis 一定很快咯？&lt;/p&gt;
&lt;p&gt;我：当然了，官方提供的数据可以达到 100000+ 的 QPS（每秒内的查询次数），这个数据不比 Memcached 差！&lt;/p&gt;
&lt;p&gt;面试官：Redis 这么快，它的“多线程模型”你了解吗？（露出邪魅一笑）&lt;/p&gt;
&lt;p&gt;我：您是想问 Redis 这么快，为什么还是单线程的吧。Redis 确实是单进程单线程的模型，因为 Redis 完全是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。&lt;/p&gt;
&lt;p&gt;既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章的采用单线程的方案了（毕竟采用多线程会有很多麻烦）。&lt;/p&gt;
&lt;p&gt;面试官：嗯，是的。那你能说说 Redis 是单线程的，为什么还能这么快吗？&lt;/p&gt;
&lt;p&gt;我：可以这么说吧，总结一下有如下四点：&lt;/p&gt;
&lt;p&gt;Redis 完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度是 O(1)。数据结构简单，对数据操作也简单。采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的 CPU 切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。使用多路复用 IO 模型，非阻塞 IO。&lt;/p&gt;
&lt;p&gt;Redis 和 Memcached 的区别&lt;/p&gt;
&lt;p&gt;面试官：嗯嗯，说的很详细。那你为什么选择 Redis 的缓存方案而不用 Memcached 呢？&lt;/p&gt;
&lt;p&gt;我：原因有如下四点：&lt;/p&gt;
&lt;p&gt;存储方式上：Memcache 会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis 有部分数据存在硬盘上，这样能保证数据的持久性。数据支持类型上：Memcache 对数据类型的支持简单，只支持简单的 key-value，，而 Redis 支持五种数据类型。使用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis 直接自己构建了 VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。Value 的大小：Redis 可以达到 1GB，而 Memcache 只有 1MB。&lt;/p&gt;
&lt;p&gt;淘汰策略&lt;/p&gt;
&lt;p&gt;面试官：那你说说你知道的 Redis 的淘汰策略有哪些？&lt;/p&gt;
&lt;p&gt;我：Redis 有六种淘汰策略，如下图：&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594804883102.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;补充一下：Redis 4.0 加入了 LFU（least frequency use）淘汰策略，包括 volatile-lfu 和 allkeys-lfu，通过统计访问频率，将访问频率最少，即最不经常使用的 KV 淘汰。&lt;/p&gt;
&lt;p&gt;持久化&lt;/p&gt;
&lt;p&gt;面试官：你对 Redis 的持久化机制了解吗？能讲一下吗？&lt;/p&gt;
&lt;p&gt;我：Redis 为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。&lt;/p&gt;
&lt;p&gt;Redis 的持久化策略有两种：&lt;/p&gt;
&lt;p&gt;RDB：快照形式是直接把内存中的数据保存到一个 dump 的文件中，定时保存，保存策略。AOF：把所有的对 Redis 的服务器进行修改的命令都存到一个文件里，命令的集合。Redis 默认是快照 RDB 的持久化方式。&lt;/p&gt;
&lt;p&gt;当 Redis 重启的时候，它会优先使用 AOF 文件来还原数据集，因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存。&lt;/p&gt;
&lt;p&gt;面试官：那你再说下 RDB 是怎么工作的？&lt;/p&gt;
&lt;p&gt;我：默认 Redis 是会以快照&amp;quot;RDB&amp;quot;的形式将数据持久化到磁盘的一个二进制文件 dump.rdb。&lt;/p&gt;
&lt;p&gt;工作原理简单说一下：当 Redis 需要做持久化时，Redis 会 fork 一个子进程，子进程将数据写到磁盘上一个临时 RDB 文件中。&lt;/p&gt;
&lt;p&gt;当子进程完成写临时文件后，将原来的 RDB 替换掉，这样的好处是可以 copy-on-write。&lt;/p&gt;
&lt;p&gt;我：RDB 的优点是：这种文件非常适合用于备份：比如，你可以在最近的 24 小时内，每小时备份一次，并且在每个月的每一天也备份一个 RDB 文件。&lt;/p&gt;
&lt;p&gt;这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适合灾难恢复。&lt;/p&gt;
&lt;p&gt;RDB 的缺点是：如果你需要尽量避免在服务器故障时丢失数据，那么RDB不合适你。&lt;/p&gt;
&lt;p&gt;面试官：那你要不再说下 AOF？&lt;/p&gt;
&lt;p&gt;我：（说就一起说下吧）使用 AOF 做持久化，每一个写命令都通过 write 函数追加到 appendonly.aof 中，配置方式如下：&lt;/p&gt;
&lt;p&gt;appendfsyncyesappendfsync always #每次有数据修改发生时都会写入AOF文件。appendfsync everysec #每秒钟同步一次，该策略为AOF的缺省策略。&lt;/p&gt;
&lt;p&gt;AOF 可以做到全程持久化，只需要在配置中开启 appendonly yes。这样 Redis 每执行一个修改数据的命令，都会把它添加到 AOF 文件中，当 Redis 重启时，将会读取 AOF 文件进行重放，恢复到 Redis 关闭前的最后时刻。&lt;/p&gt;
&lt;p&gt;我顿了一下，继续说：使用 AOF 的优点是会让 Redis 变得非常耐久。可以设置不同的 Fsync 策略，AOF的默认策略是每秒钟 Fsync 一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。&lt;/p&gt;
&lt;p&gt;缺点是对于相同的数据集来说，AOF 的文件体积通常要大于 RDB 文件的体积。根据所使用的 Fsync 策略，AOF 的速度可能会慢于 RDB。&lt;/p&gt;
&lt;p&gt;面试官又问：你说了这么多，那我该用哪一个呢？&lt;/p&gt;
&lt;p&gt;我：如果你非常关心你的数据，但仍然可以承受数分钟内的数据丢失，那么可以额只使用 RDB 持久。&lt;/p&gt;
&lt;p&gt;AOF 将 Redis 执行的每一条命令追加到磁盘中，处理巨大的写入会降低Redis的性能，不知道你是否可以接受。&lt;/p&gt;
&lt;p&gt;数据库备份和灾难恢复：定时生成 RDB 快照非常便于进行数据库备份，并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度快。&lt;/p&gt;
&lt;p&gt;当然了，Redis 支持同时开启 RDB 和 AOF，系统重启后，Redis 会优先使用 AOF 来恢复数据，这样丢失的数据会最少。&lt;/p&gt;
&lt;p&gt;主从复制&lt;/p&gt;
&lt;p&gt;面试官：Redis 单节点存在单点故障问题，为了解决单点问题，一般都需要对 Redis 配置从节点，然后使用哨兵来监听主节点的存活状态，如果主节点挂掉，从节点能继续提供缓存功能，你能说说 Redis 主从复制的过程和原理吗？&lt;/p&gt;
&lt;p&gt;我有点懵，这个说来就话长了。但幸好提前准备了：主从配置结合哨兵模式能解决单点故障问题，提高 Redis 可用性。&lt;/p&gt;
&lt;p&gt;从节点仅提供读操作，主节点提供写操作。对于读多写少的状况，可给主节点配置多个从节点，从而提高响应效率。&lt;/p&gt;
&lt;p&gt;我顿了一下，接着说：关于复制过程，是这样的：&lt;/p&gt;
&lt;p&gt;从节点执行 slaveof[masterIP][masterPort]，保存主节点信息。从节点中的定时任务发现主节点信息，建立和主节点的 Socket 连接。从节点发送 Ping 信号，主节点返回 Pong，两边能互相通信。连接建立后，主节点将所有数据发送给从节点（数据同步）。主节点把当前的数据同步给从节点后，便完成了复制的建立过程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。&lt;/p&gt;
&lt;p&gt;面试官：那你能详细说下数据同步的过程吗？&lt;/p&gt;
&lt;p&gt;（我心想：这也问的太细了吧）我：可以。Redis 2.8 之前使用 sync[runId][offset] 同步命令，Redis 2.8 之后使用 psync[runId][offset] 命令。&lt;/p&gt;
&lt;p&gt;两者不同在于，Sync 命令仅支持全量复制过程，Psync 支持全量和部分复制。&lt;/p&gt;
&lt;p&gt;介绍同步之前，先介绍几个概念：&lt;/p&gt;
&lt;p&gt;runId：每个 Redis 节点启动都会生成唯一的 uuid，每次 Redis 重启后，runId 都会发生变化。offset：主节点和从节点都各自维护自己的主从复制偏移量 offset，当主节点有写入命令时，offset=offset+命令的字节长度。从节点在收到主节点发送的命令后，也会增加自己的 offset，并把自己的 offset 发送给主节点。这样，主节点同时保存自己的 offset 和从节点的 offset，通过对比 offset 来判断主从节点数据是否一致。repl_backlog_size：保存在主节点上的一个固定长度的先进先出队列，默认大小是 1MB。&lt;/p&gt;
&lt;p&gt;主节点发送数据给从节点过程中，主节点还会进行一些写操作，这时候的数据存储在复制缓冲区中。&lt;/p&gt;
&lt;p&gt;从节点同步主节点数据完成后，主节点将缓冲区的数据继续发送给从节点，用于部分复制。&lt;/p&gt;
&lt;p&gt;主节点响应写命令时，不但会把命名发送给从节点，还会写入复制积压缓冲区，用于复制命令丢失的数据补救。&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594804920017.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面是 Psync 的执行流程，从节点发送 psync[runId][offset] 命令，主节点有三种响应：&lt;/p&gt;
&lt;p&gt;FULLRESYNC：第一次连接，进行全量复制CONTINUE：进行部分复制ERR：不支持 psync 命令，进行全量复制&lt;/p&gt;
&lt;p&gt;面试官：很好，那你能具体说下全量复制和部分复制的过程吗？&lt;/p&gt;
&lt;p&gt;我：可以！&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594804931683.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面是全量复制的流程。主要有以下几步：&lt;/p&gt;
&lt;p&gt;从节点发送 psync ? -1 命令（因为第一次发送，不知道主节点的 runId，所以为?，因为是第一次复制，所以 offset=-1）。主节点发现从节点是第一次复制，返回 FULLRESYNC {runId} {offset}，runId 是主节点的 runId，offset 是主节点目前的 offset。从节点接收主节点信息后，保存到 info 中。主节点在发送 FULLRESYNC 后，启动 bgsave 命令，生成 RDB 文件（数据持久化）。主节点发送 RDB 文件给从节点。到从节点加载数据完成这段期间主节点的写命令放入缓冲区。从节点清理自己的数据库数据。从节点加载 RDB 文件，将数据保存到自己的数据库中。如果从节点开启了 AOF，从节点会异步重写 AOF 文件。&lt;/p&gt;
&lt;p&gt;关于部分复制有以下几点说明：&lt;/p&gt;
&lt;p&gt;①部分复制主要是 Redis 针对全量复制的过高开销做出的一种优化措施，使用 psync[runId][offset] 命令实现。&lt;/p&gt;
&lt;p&gt;当从节点正在复制主节点时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向主节点要求补发丢失的命令数据，主节点的复制积压缓冲区将这部分数据直接发送给从节点。&lt;/p&gt;
&lt;p&gt;这样就可以保持主从节点复制的一致性。补发的这部分数据一般远远小于全量数据。&lt;/p&gt;
&lt;p&gt;②主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内的复制积压缓冲区依然可以保存最近一段时间的写命令数据。&lt;/p&gt;
&lt;p&gt;③当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行 ID。因此会把它们当做 psync 参数发送给主节点，要求进行部分复制。&lt;/p&gt;
&lt;p&gt;④主节点接收到 psync 命令后首先核对参数 runId 是否与自身一致，如果一致，说明之前复制的是当前主节点。&lt;/p&gt;
&lt;p&gt;之后根据参数 offset 在复制积压缓冲区中查找，如果 offset 之后的数据存在，则对从节点发送+COUTINUE 命令，表示可以进行部分复制。因为缓冲区大小固定，若发生缓冲溢出，则进行全量复制。&lt;/p&gt;
&lt;p&gt;⑤主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。&lt;/p&gt;
&lt;p&gt;哨兵&lt;/p&gt;
&lt;p&gt;面试官：那主从复制会存在哪些问题呢？&lt;/p&gt;
&lt;p&gt;我：主从复制会存在以下问题：&lt;/p&gt;
&lt;p&gt;一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。主节点的写能力受到单机的限制。主节点的存储能力受到单机的限制。原生复制的弊端在早期的版本中也会比较突出，比如：Redis 复制中断后，从节点会发起 psync。此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。&lt;/p&gt;
&lt;p&gt;面试官：那比较主流的解决方案是什么呢？&lt;/p&gt;
&lt;p&gt;我：当然是哨兵啊。&lt;/p&gt;
&lt;p&gt;面试官：那么问题又来了。那你说下哨兵有哪些功能？&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594804960017.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;我：如图，是 Redis Sentinel（哨兵）的架构图。Redis Sentinel（哨兵）主要功能包括主节点存活检测、主从运行情况检测、自动故障转移、主从切换。&lt;/p&gt;
&lt;p&gt;Redis Sentinel 最小配置是一主一从。Redis 的 Sentinel 系统可以用来管理多个 Redis 服务器。&lt;/p&gt;
&lt;p&gt;该系统可以执行以下四个任务：&lt;/p&gt;
&lt;p&gt;监控：不断检查主服务器和从服务器是否正常运行。通知：当被监控的某个 Redis 服务器出现问题，Sentinel 通过 API 脚本向管理员或者其他应用程序发出通知。自动故障转移：当主节点不能正常工作时，Sentinel 会开始一次自动的故障转移操作，它会将与失效主节点是主从关系的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点，这样人工干预就可以免了。配置提供者：在 Redis Sentinel 模式下，客户端应用在初始化时连接的是 Sentinel 节点集合，从中获取主节点的信息。&lt;/p&gt;
&lt;p&gt;面试官：那你能说下哨兵的工作原理吗？&lt;/p&gt;
&lt;p&gt;我：话不多说，直接上图：&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594804973751.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;①每个 Sentinel 节点都需要定期执行以下任务：每个 Sentinel 以每秒一次的频率，向它所知的主服务器、从服务器以及其他的 Sentinel 实例发送一个 PING 命令。（如上图）&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594804993952.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
②如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 所指定的值，那么这个实例会被 Sentinel 标记为主观下线。（如上图）&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594805012749.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
③如果一个主服务器被标记为主观下线，那么正在监视这个服务器的所有 Sentinel 节点，要以每秒一次的频率确认主服务器的确进入了主观下线状态。&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594805019800.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
④如果一个主服务器被标记为主观下线，并且有足够数量的 Sentinel（至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断，那么这个主服务器被标记为客观下线。&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594805026319.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
⑤一般情况下，每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO 命令。&lt;/p&gt;
&lt;p&gt;当一个主服务器被标记为客观下线时，Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率，会从 10 秒一次改为每秒一次。&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594805063751.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
⑥Sentinel 和其他 Sentinel 协商客观下线的主节点的状态，如果处于 SDOWN 状态，则投票自动选出新的主节点，将剩余从节点指向新的主节点进行数据复制。&lt;br&gt;
&lt;img src=&#34;https://Dawn-cheng.github.io/post-images/1594805073138.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
⑦当没有足够数量的 Sentinel 同意主服务器下线时，主服务器的客观下线状态就会被移除。&lt;/p&gt;
&lt;p&gt;当主服务器重新向 Sentinel 的 PING 命令返回有效回复时，主服务器的主观下线状态就会被移除。&lt;/p&gt;
&lt;p&gt;面试官：不错，面试前没少下工夫啊，今天 Redis 这关你过了，明天找个时间我们再聊聊其他的。（露出欣慰的微笑）&lt;/p&gt;
&lt;p&gt;我：没问题。&lt;/p&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;本文在一次面试的过程中讲述了 Redis 是什么，Redis 的特点和功能，Redis 缓存的使用，Redis 为什么能这么快，Redis 缓存的淘汰策略，持久化的两种方式，Redis 高可用部分的主从复制和哨兵的基本原理。&lt;/p&gt;
&lt;p&gt;文章转载：https://baijiahao.baidu.com/s?id=1660009541007805174&amp;amp;wfr=spider&amp;amp;for=pc&lt;/p&gt;
">搞懂这些Redis知识点，吊打面试官！</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://Dawn-cheng.github.io/linux-ming-ling/"" data-c="
          &lt;p&gt;一、开关机&lt;br&gt;
sync ：把内存中的数据写到磁盘中（关机、重启前都需先执行sync）&lt;br&gt;
shutdown -rnow或reboot ：立刻重启&lt;br&gt;
shutdown -hnow ：立刻关机&lt;br&gt;
shutdown -h 19:00 ：预定时间关闭系统（晚上7点关机，如果现在超过8点则第二天）&lt;br&gt;
shutdown -h +10 ：预定时间关闭系统（10分钟后关机）&lt;br&gt;
shutdown -c ：取消按预定时间关闭系统&lt;br&gt;
init 0 ：关闭系统&lt;br&gt;
telinit 0 ：关闭系统&lt;br&gt;
logout ：注销&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;二、系统信息&lt;br&gt;
arch ：显示机器的处理器架构&lt;br&gt;
uname -m ：显示机器的处理器架构&lt;br&gt;
uname -r ：显示正在使用的内核版本&lt;br&gt;
dmidecode -q ：显示硬件系统部件 - (SMBIOS / DMI)&lt;br&gt;
hdparm -i /dev/hda ：罗列一个磁盘的架构特性&lt;br&gt;
hdparm -tT /dev/sda ：在磁盘上执行测试性读取操作&lt;br&gt;
cat /proc/cpuinfo ：显示CPU info的信息&lt;br&gt;
cat /proc/interrupts ：显示中断&lt;br&gt;
cat /proc/meminfo ：校验内存使用&lt;br&gt;
cat /proc/swaps ：显示哪些swap被使用&lt;br&gt;
cat /proc/version ：显示内核的版本&lt;br&gt;
cat /proc/net/dev ：显示网络适配器及统计&lt;br&gt;
cat /proc/mounts ：显示已加载的文件系统&lt;br&gt;
cat /etc/passwd :显示密码信息&lt;br&gt;
lspci -tv ：罗列 PCI 设备&lt;br&gt;
lsusb -tv ：显示 USB 设备&lt;br&gt;
date ：显示系统日期&lt;br&gt;
cal 2007 ：显示2007年的日历表&lt;br&gt;
date 041217002007.00 ：设置日期和时间 - 月日时分年.秒&lt;br&gt;
clock -w ：将时间修改保存到 BIOS&lt;br&gt;
who ami：查看当前使用的终端&lt;br&gt;
who或w ：查看所有终端&lt;br&gt;
uname -m ：显示机器的处理器架构（如x86_64）&lt;br&gt;
uname -f: 显示系统信息&lt;br&gt;
 三、文件和目录&lt;br&gt;
cd /home：进入 &#39;/ home&#39; 目录&#39;&lt;br&gt;
cd .. ：返回上一级目录&lt;br&gt;
cd ../.. ：返回上两级目录&lt;br&gt;
cd ：进入个人的主目录&lt;br&gt;
cd ~ ：进入个人的主目录&lt;br&gt;
cd - ：返回上次所在的目录&lt;br&gt;
pwd ：显示当前工作路径&lt;br&gt;
ls ：查看目录中的文件&lt;br&gt;
ls -F ：查看目录中的文件&lt;br&gt;
ls -l ：显示文件和目录的详细资料&lt;br&gt;
ls -a ：显示隐藏文件 ls &lt;em&gt;[0-9]&lt;/em&gt; 显示包含数字的文件名和目录名&lt;br&gt;
tree ：显示文件和目录由根目录开始的树形结构&lt;br&gt;
lstree ：显示文件和目录由根目录开始的树形结构&lt;br&gt;
mkdir dir1 ：创建一个叫做 &#39;dir1&#39; 的目录&#39;&lt;br&gt;
mkdir dir1 dir2 ：同时创建两个目录&lt;br&gt;
mkdir -p /tmp/dir1/dir2 ：创建一个目录树&lt;br&gt;
rm -f file1 ：删除一个叫做 &#39;file1&#39; 的文件&#39;&lt;br&gt;
rmdir dir1 ：删除一个叫做 &#39;dir1&#39; 的目录&#39;&lt;br&gt;
rm -rf dir1 ：删除一个叫做 &#39;dir1&#39; 的目录并同时删除其内容&lt;br&gt;
rm -rf dir1 dir2 ：同时删除两个目录及它们的内容&lt;br&gt;
mv dir1 new_dir ：重命名/移动 一个目录&lt;br&gt;
cp file1 file2 ：复制一个文件 cp dir/* . 复制一个目录下的所有文件到当前工作目录&lt;br&gt;
cp -a /tmp/dir1 ：复制一个目录到当前工作目录&lt;br&gt;
cp -a dir1 dir2 ：复制一个目录&lt;br&gt;
ln -s file1 lnk1 ：创建一个指向文件或目录的软链接&lt;br&gt;
ln file1 lnk1 ：创建一个指向文件或目录的物理链接&lt;br&gt;
touch “test”：创建一个名为test的文件&lt;br&gt;
四、文件搜索&lt;br&gt;
find / -name file1 ：从 &#39;/&#39; 开始进入根文件系统搜索文件和目录&lt;br&gt;
find / -user user1 ：搜索属于用户 &#39;user1&#39; 的文件和目录&lt;br&gt;
find /home/user1 -name *.bin ：在目录 &#39;/ home/user1&#39; 中搜索带有&#39;.bin&#39; 结尾的文件&lt;br&gt;
find /usr/bin -type f -atime +100 ：搜索在过去100天内未被使用过的执行文件&lt;br&gt;
find /usr/bin -type f -mtime -10 ：搜索在10天内被创建或者修改过的文件&lt;br&gt;
find / -name *.rpm -exec chmod 755 &#39;{}&#39; \ ：搜索以 &#39;.rpm&#39; 结尾的文件并定义其权限&lt;br&gt;
find / -xdev -name *.rpm ：搜索以 &#39;.rpm&#39; 结尾的文件，忽略光驱、捷盘等可移动设备&lt;br&gt;
locate *.ps ：寻找以 &#39;.ps&#39; 结尾的文件 - 先运行 &#39;updatedb&#39; 命令&lt;br&gt;
whereis halt ：显示一个二进制文件、源码或man的位置&lt;br&gt;
which halt ：显示一个二进制文件或可执行文件的完整路径&lt;br&gt;
 五、挂载系统文件&lt;br&gt;
mount /dev/hda2 /mnt/hda2 ：挂载一个叫做hda2的盘 - 确定目录 &#39;/ mnt/hda2&#39; 已经存在&lt;br&gt;
umount /dev/hda2 ：卸载一个叫做hda2的盘 - 先从挂载点 &#39;/ mnt/hda2&#39; 退出&lt;br&gt;
fuser -km /mnt/hda2 ：当设备繁忙时强制卸载&lt;br&gt;
umount -n /mnt/hda2 ：运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用&lt;br&gt;
mount /dev/fd0 /mnt/floppy ：挂载一个软盘&lt;br&gt;
mount /dev/cdrom /mnt/cdrom ：挂载一个cdrom或dvdrom&lt;br&gt;
mount /dev/hdc /mnt/cdrecorder ：挂载一个cdrw或dvdrom&lt;br&gt;
mount /dev/hdb /mnt/cdrecorder ：挂载一个cdrw或dvdrom&lt;br&gt;
mount -o loop file.iso /mnt/cdrom ：挂载一个文件或ISO镜像文件&lt;br&gt;
mount -t vfat /dev/hda5 /mnt/hda5 ：挂载一个Windows FAT32文件系统&lt;br&gt;
mount /dev/sda1 /mnt/usbdisk ：挂载一个usb 捷盘或闪存设备&lt;br&gt;
mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share ：挂载一个windows网络共享&lt;br&gt;
 五、用户和群组&lt;br&gt;
useradd 用户名 ：创建用户&lt;br&gt;
userdel -r 用户名 :删除用户：（-r表示把用户的主目录一起删除）&lt;br&gt;
usermod -g 组名 用户名 ：修改用户的组&lt;br&gt;
usermod -aG 组名 用户名 ：将用户添加到组&lt;br&gt;
groups test ：查看test用户所在的组&lt;br&gt;
cat /etc/group |grep test ：查看test用户详情：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell&lt;br&gt;
passwd [ludf] 用户名 ：用户改自己密码，不需要输入用户名，选项-d:指定空口令,-l:禁用某用户，-u解禁某用户，-f：强迫用户下次登录时修改口令&lt;br&gt;
groupadd 组名 ：创建用户组&lt;br&gt;
groupdel 用户组 ：删除组&lt;br&gt;
groupmod -n 新组名 旧组名 ：修改用户组名字&lt;br&gt;
su - 用户名：完整的切换到一个用户环境（相当于登录）（建议用这个）（退出用户：exit）&lt;br&gt;
su 用户名 :切换到用户的身份（环境变量等没变，导致很多命令要加上绝对路径才能执行）&lt;br&gt;
sudo 命令 ：以root的身份执行命令（输入用户自己的密码，而su为输入要切换用户的密码，普通用户需设置/etc/sudoers才可用sudo）&lt;br&gt;
chage -E 2005-12-31 用户名：设置用户口令的失效期限&lt;br&gt;
pwck ：检查 &#39;/etc/passwd&#39; 的文件格式和语法修正以及存在的用户&lt;br&gt;
grpck ：检查 &#39;/etc/passwd&#39; 的文件格式和语法修正以及存在的群组&lt;br&gt;
newgrp group_name ：登陆进一个新的群组以改变新创建文件的预设群组&lt;br&gt;
 六、文件权限操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 u 表示“用户（user）”，即文件或者目录所有者。&lt;/li&gt;
&lt;li&gt;2 g 表示“同组（group）用户”，即文件属主有相同组ID的所有用户。&lt;/li&gt;
&lt;li&gt;3 o 表示“其他（others）用户”，即系统默认值。&lt;/li&gt;
&lt;li&gt;1 文字设定：（r：可读）、（w：可写）、（ x：可执行）&lt;/li&gt;
&lt;li&gt;2 数字设定：（r：4）、（w：2）、（ x：1）&lt;br&gt;
chmod ugo+rwx test.txt: 表示分别给test.txt文件g、u、o用户可读、可写、可执行权限(也可单独给权限用逗号隔开)&lt;br&gt;
chmod 777 test.txt: 表示分别test.txt文件 g、u、o用户可读、可写、可执行权限（数字表示）&lt;br&gt;
chmod u-wx test.txt：表示删除test.txt文件 u用户可写、可执行权限。&lt;br&gt;
 七、打包压缩文件&lt;br&gt;
bunzip2 file1.bz2 ：解压一个叫做 &#39;file1.bz2&#39;的文件&lt;br&gt;
bzip2 file1 ：压缩一个叫做 &#39;file1&#39; 的文件&lt;br&gt;
gunzip file1.gz ：解压一个叫做 &#39;file1.gz&#39;的文件&lt;br&gt;
gzip file1 ：压缩一个叫做 &#39;file1&#39;的文件&lt;br&gt;
gzip -9 file1 ：最大程度压缩&lt;br&gt;
rar a file1.rar test_file ：创建一个叫做 &#39;file1.rar&#39; 的包&lt;br&gt;
rar a file1.rar file1 file2 dir1 ：同时压缩 &#39;file1&#39;, &#39;file2&#39; 以及目录 &#39;dir1&#39;&lt;br&gt;
rar x file1.rar ：解压rar包&lt;br&gt;
unrar x file1.rar ：解压rar包&lt;br&gt;
tar -cvf archive.tar file1 ：创建一个非压缩的 tarball&lt;br&gt;
tar -cvf archive.tar file1 file2 dir1 ：创建一个包含了 &#39;file1&#39;, &#39;file2&#39; 以及 &#39;dir1&#39;的档案文件&lt;br&gt;
tar -tf archive.tar ：显示一个包中的内容&lt;br&gt;
tar -xvf archive.tar ：释放一个包&lt;br&gt;
tar -xvf archive.tar -C /tmp ：将压缩包释放到 /tmp目录下&lt;br&gt;
tar -cvfj archive.tar.bz2 dir1 ：创建一个bzip2格式的压缩包&lt;br&gt;
tar -jxvf archive.tar.bz2 ：解压一个bzip2格式的压缩包&lt;br&gt;
tar -cvfz archive.tar.gz dir1 ：创建一个gzip格式的压缩包&lt;br&gt;
tar -zxvf archive.tar.gz ：解压一个gzip格式的压缩包&lt;br&gt;
zip file1.zip file1 ：创建一个zip格式的压缩包&lt;br&gt;
zip -r file1.zip file1 file2 dir1 ：将几个文件和目录同时压缩成一个zip格式的压缩包&lt;br&gt;
unzip file1.zip ：解压一个zip格式压缩包&lt;br&gt;
 八、RPM包&lt;br&gt;
rpm -ivh 名字.rpm ：安装一个rpm包&lt;br&gt;
rpm -ivh --nodeeps package.rpm ：安装一个rpm包而忽略依赖关系警告&lt;br&gt;
rpm -U package.rpm ：更新一个rpm包但不改变其配置文件&lt;br&gt;
rpm -F package.rpm ：更新一个确定已经安装的rpm包&lt;br&gt;
rpm -e package_name.rpm ：删除一个rpm包&lt;br&gt;
rpm -qa ：显示系统中所有已经安装的rpm包&lt;br&gt;
rpm -qa | grep httpd ：显示所有名称中包含 &amp;quot;httpd&amp;quot; 字样的rpm包&lt;br&gt;
rpm -qi package_name ：获取一个已安装包的特殊信息&lt;br&gt;
rpm -qg &amp;quot;System Environment/Daemons&amp;quot; ：显示一个组件的rpm包&lt;br&gt;
rpm -ql package_name ：显示一个已经安装的rpm包提供的文件列表&lt;br&gt;
rpm -qc package_name ：显示一个已经安装的rpm包提供的配置文件列表&lt;br&gt;
rpm -q package_name --whatrequires ：显示与一个rpm包存在依赖关系的列表&lt;br&gt;
rpm -q package_name --whatprovides ：显示一个rpm包所占的体积&lt;br&gt;
rpm -q package_name --scripts ：显示在安装/删除期间所执行的脚本l&lt;br&gt;
rpm -q package_name --changelog ：显示一个rpm包的修改历史&lt;br&gt;
rpm -qf /etc/httpd/conf/httpd.conf ：确认所给的文件由哪个rpm包所提供&lt;br&gt;
rpm -qp package.rpm -l ：显示由一个尚未安装的rpm包提供的文件列表&lt;br&gt;
rpm --import /media/cdrom/RPM-GPG-KEY ：导入公钥数字证书&lt;br&gt;
rpm --checksig package.rpm ：确认一个rpm包的完整性&lt;br&gt;
rpm -qa gpg-pubkey ：确认已安装的所有rpm包的完整性&lt;br&gt;
rpm -V package_name ：检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间&lt;br&gt;
rpm -Va ：检查系统中所有已安装的rpm包- 小心使用&lt;br&gt;
rpm -Vp package.rpm ：确认一个rpm包还未安装&lt;br&gt;
rpm2cpio package.rpm | cpio --extract --make-directories &lt;em&gt;bin&lt;/em&gt; ：从一个rpm包运行可执行文件&lt;br&gt;
rpm -ivh /usr/src/redhat/RPMS/&lt;code&gt;arch&lt;/code&gt;/package.rpm ：从一个rpm源码安装一个构建好的包&lt;br&gt;
rpmbuild --rebuild package_name.src.rpm ：从一个rpm源码构建一个 rpm 包&lt;br&gt;
 九、yum软件包&lt;br&gt;
yum install 软件名：下载并安装一个rpm包&lt;br&gt;
yum localinstall 软件包名： 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系&lt;br&gt;
yum update 软件包名.rpm ：更新当前系统中所有安装的rpm包&lt;br&gt;
yum update 软件包名：更新一个rpm包&lt;br&gt;
yum remove 软件包名： 删除一个rpm包&lt;br&gt;
yum list：列出当前系统中安装的所有包&lt;br&gt;
yum search 软件包名： 在rpm仓库中搜寻软件包&lt;br&gt;
yum clean packages ：清理rpm缓存删除下载的包&lt;br&gt;
yum clean headers ：删除所有头文件&lt;br&gt;
yum clean all ：删除所有缓存的包和头文件&lt;br&gt;
 十、磁盘管理&lt;br&gt;
df -h :显示磁盘的空间使用情况 及挂载点&lt;br&gt;
df -h /var/log :（显示log所在分区（挂载点）、目录所在磁盘及可用的磁盘容量）&lt;br&gt;
du -sm /var/log/* | sort -rn : 根据占用磁盘空间大小排序（MB）某目录下文件和目录大小&lt;br&gt;
fdisk -l :查所有分区及总容量，加/dev/sda为查硬盘a的分区）&lt;br&gt;
fdisk /dev/sdb :对硬盘sdb进行分区&lt;br&gt;
mount /dev/sda1 /mnt ：硬盘sda1挂载到/mnt目录（mount 装置文件名 挂载点）&lt;br&gt;
mount -t cifs -o username=luolanguo,password=win用户账号密码,vers=3.0 //10.2.1.178/G /mnt/usb :远程linux 共享挂载windows的U盘,G为U盘共享名，需设置U盘共享&lt;br&gt;
mount -o loop /opt/soft/CentOS-7-x86_64-DVD-1708.iso /media/CentOS ：挂载iso文件&lt;br&gt;
umount /dev/sda1 ：取消挂载（umount 装置文件名或挂载点）&lt;br&gt;
 十一、DEB包&lt;br&gt;
dpkg -i package.deb ：安装/更新一个 deb 包&lt;br&gt;
dpkg -r package_name ：从系统删除一个 deb 包&lt;br&gt;
dpkg -l ：显示系统中所有已经安装的 deb 包&lt;br&gt;
dpkg -l | grep httpd ：显示所有名称中包含 &amp;quot;httpd&amp;quot; 字样的deb包&lt;br&gt;
dpkg -s package_name ：获得已经安装在系统中一个特殊包的信息&lt;br&gt;
dpkg -L package_name ：显示系统中已经安装的一个deb包所提供的文件列表&lt;br&gt;
dpkg --contents package.deb ：显示尚未安装的一个包所提供的文件列表&lt;br&gt;
dpkg -S /bin/ping ：确认所给的文件由哪个deb包提供&lt;br&gt;
 十二、APT软件工具&lt;br&gt;
apt-get install package_name ：安装/更新一个 deb 包&lt;br&gt;
apt-cdrom install package_name ：从光盘安装/更新一个 deb 包&lt;br&gt;
apt-get update ：升级列表中的软件包&lt;br&gt;
apt-get upgrade ：升级所有已安装的软件&lt;br&gt;
apt-get remove package_name ：从系统删除一个deb包&lt;br&gt;
apt-get check ：确认依赖的软件仓库正确&lt;br&gt;
apt-get clean ：从下载的软件包中清理缓存&lt;br&gt;
apt-cache search searched-package ：返回包含所要搜索字符串的软件包名称&lt;br&gt;
十三、文本处理&lt;br&gt;
cat file1 file2 ... | command &amp;lt;&amp;gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT&lt;br&gt;
cat file1 | command( sed, grep, awk, grep, etc...) &amp;gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中&lt;br&gt;
cat file1 | command( sed, grep, awk, grep, etc...) &amp;gt;&amp;gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中&lt;br&gt;
grep Aug /var/log/messages 在文件 &#39;/var/log/messages&#39;中查找关键词&amp;quot;Aug&amp;quot;&lt;br&gt;
grep ^Aug /var/log/messages 在文件 &#39;/var/log/messages&#39;中查找以&amp;quot;Aug&amp;quot;开始的词汇&lt;br&gt;
grep [0-9] /var/log/messages 选择 &#39;/var/log/messages&#39; 文件中所有包含数字的行&lt;br&gt;
grep Aug -R /var/log/* 在目录 &#39;/var/log&#39; 及随后的目录中搜索字符串&amp;quot;Aug&amp;quot;&lt;br&gt;
sed &#39;s/stringa1/stringa2/g&#39; example.txt 将example.txt文件中的 &amp;quot;string1&amp;quot; 替换成 &amp;quot;string2&amp;quot;&lt;br&gt;
sed &#39;/^&lt;span class=&#39;katex-error&#39; title=&#39;ParseError: KaTeX parse error: Expected &amp;#039;EOF&amp;#039;, got &amp;#039;#&amp;#039; at position 48: …除所有空白行
sed &amp;#039;/ *#̲/d; /^&#39;&gt;/d&amp;#039; example.txt 从example.txt文件中删除所有空白行
sed &amp;#039;/ *#/d; /^&lt;/span&gt;/d&#39; example.txt 从example.txt文件中删除所有注释和空白行&lt;br&gt;
echo &#39;esempio&#39; | tr &#39;[:lower:]&#39; &#39;[:upper:]&#39; 合并上下单元格内容&lt;br&gt;
sed -e &#39;1d&#39; result.txt 从文件example.txt 中排除第一行&lt;br&gt;
sed -n &#39;/stringa1/p&#39; 查看只包含词汇 &amp;quot;string1&amp;quot;的行&lt;br&gt;
sed -e &#39;s/ &lt;em&gt;$//&#39; example.txt 删除每一行最后的空白字符&lt;br&gt;
sed -e &#39;s/stringa1//g&#39; example.txt 从文档中只删除词汇 &amp;quot;string1&amp;quot; 并保留剩余全部&lt;br&gt;
sed -n &#39;1,5p;5q&#39; example.txt 查看从第一行到第5行内容&lt;br&gt;
sed -n &#39;5p;5q&#39; example.txt 查看第5行&lt;br&gt;
sed -e &#39;s/00&lt;/em&gt;/0/g&#39; example.txt 用单个零替换多个零&lt;br&gt;
cat -n file1 标示文件的行数&lt;br&gt;
cat example.txt | awk &#39;NR%2==1&#39; 删除example.txt文件中的所有偶数行&lt;br&gt;
echo a b c | awk &#39;{print $1}&#39; 查看一行第一栏&lt;br&gt;
echo a b c | awk &#39;{print $1,$3}&#39; 查看一行的第一和第三栏&lt;br&gt;
paste file1 file2 合并两个文件或两栏的内容&lt;br&gt;
paste -d &#39;+&#39; file1 file2 合并两个文件或两栏的内容，中间用&amp;quot;+&amp;quot;区分&lt;br&gt;
sort file1 file2 排序两个文件的内容&lt;br&gt;
sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)&lt;br&gt;
sort file1 file2 | uniq -u 删除交集，留下其他的行&lt;br&gt;
sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)&lt;br&gt;
comm -1 file1 file2 比较两个文件的内容只删除 &#39;file1&#39; 所包含的内容&lt;br&gt;
comm -2 file1 file2 比较两个文件的内容只删除 &#39;file2&#39; 所包含的内容&lt;br&gt;
comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分&lt;br&gt;
十四、字符设置和文件格式转换 &lt;br&gt;
dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX&lt;br&gt;
unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS&lt;br&gt;
recode ..HTML &amp;lt; page.txt &amp;gt; page.html 将一个文本文件转换成html&lt;br&gt;
recode -l | more 显示所有允许的转换格式&lt;br&gt;
  十五、文件系统分析 &lt;br&gt;
badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块&lt;br&gt;
fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性&lt;br&gt;
fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性&lt;br&gt;
e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性&lt;br&gt;
e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性&lt;br&gt;
fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性&lt;br&gt;
fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性&lt;br&gt;
fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性&lt;br&gt;
dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性&lt;br&gt;
十六、初始化一个文件系统&lt;br&gt;
mkfs /dev/hda1 在hda1分区创建一个文件系统&lt;br&gt;
mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统&lt;br&gt;
mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统&lt;br&gt;
mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统&lt;br&gt;
fdformat -n /dev/fd0 格式化一个软盘&lt;br&gt;
mkswap /dev/hda3 创建一个swap文件系统&lt;br&gt;
十七、SWAP文件系统&lt;br&gt;
mkswap /dev/hda3 创建一个swap文件系统&lt;br&gt;
swapon /dev/hda3 启用一个新的swap文件系统&lt;br&gt;
swapon /dev/hda2 /dev/hdb3 启用两个swap分区&lt;br&gt;
十八、备份&lt;br&gt;
dump -0aj -f /tmp/home0.bak /home 制作一个 &#39;/home&#39; 目录的完整备份&lt;br&gt;
dump -1aj -f /tmp/home0.bak /home 制作一个 &#39;/home&#39; 目录的交互式备份&lt;br&gt;
restore -if /tmp/home0.bak 还原一个交互式备份&lt;br&gt;
rsync -rogpav --delete /home /tmp 同步两边的目录&lt;br&gt;
rsync -rogpav -e ssh --delete /home ip_address:/tmp 通过SSH通道rsync&lt;br&gt;
rsync -az -e ssh --delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录&lt;br&gt;
rsync -az -e ssh --delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录&lt;br&gt;
dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr &#39;dd of=hda.gz&#39; 通过ssh在远程主机上执行一次备份本地磁盘的操作&lt;br&gt;
dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件&lt;br&gt;
tar -Puf backup.tar /home/user 执行一次对 &#39;/home/user&#39; 目录的交互式备份操作&lt;br&gt;
( cd /tmp/local/ &amp;amp;&amp;amp; tar c . ) | ssh -C user@ip_addr &#39;cd /home/share/ &amp;amp;&amp;amp; tar x -p&#39; 通过ssh在远程目录中复制一个目录内容&lt;br&gt;
( tar c /home ) | ssh -C user@ip_addr &#39;cd /home/backup-home &amp;amp;&amp;amp; tar x -p&#39; 通过ssh在远程目录中复制一个本地目录&lt;br&gt;
tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接&lt;br&gt;
find /home/user1 -name &#39;&lt;em&gt;.txt&#39; | xargs cp -av --target-directory=/home/backup/ --parents 从一个目录查找并复制所有以 &#39;.txt&#39; 结尾的文件到另一个目录&lt;br&gt;
find /var/log -name &#39;&lt;/em&gt;.log&#39; | tar cv --files-from=- | bzip2 &amp;gt; log.tar.bz2 查找所有以 &#39;.log&#39; 结尾的文件并做成一个bzip包&lt;br&gt;
dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作&lt;br&gt;
dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容&lt;/li&gt;
&lt;/ul&gt;
">Linux命令</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>


<script src="/media/js/mouse/love.js"></script>





</html>